// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package tidbcloud

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	// Page The number of pages.
	Page *int64 `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The size of a page.
	PageSize *int64 `form:"page_size,omitempty" json:"page_size,omitempty"`
}

// CreateProjectJSONBody defines parameters for CreateProject.
type CreateProjectJSONBody struct {
	// AwsCmekEnabled Flag that indicates whether to enable AWS Customer-Managed Encryption Keys.
	//
	// Currently this feature is only available upon request. If you need to try out this feature, contact [support](https://docs.pingcap.com/tidbcloud/tidb-cloud-support).
	AwsCmekEnabled *bool `json:"aws_cmek_enabled,omitempty"`

	// Name The name of the project.
	Name string `json:"name"`
}

// CreateAwsCmekJSONBody defines parameters for CreateAwsCmek.
type CreateAwsCmekJSONBody struct {
	// Specs The specification of the AWS CMEK. You can configure multiple AWS CMEKs.
	//
	// For a particular project, CMEK can only be configured for one AWS region. Once configured, you cannot create clusters in other regions in the same project.
	Specs []struct {
		// KmsArn The KMS ARN of the AWS CMEK.
		KmsArn string `json:"kms_arn"`

		// Region The region name of the AWS CMEK. The region value should match the cloud provider's region code.
		//
		// You can get the complete list of available regions from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
		//
		// For the detailed information on each region, refer to the documentation of the [AWS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html) cloud provider.
		Region string `json:"region"`
	} `json:"specs"`
}

// ListClustersOfProjectParams defines parameters for ListClustersOfProject.
type ListClustersOfProjectParams struct {
	// Page The number of pages.
	Page *int64 `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The size of a page.
	PageSize *int64 `form:"page_size,omitempty" json:"page_size,omitempty"`
}

// CreateClusterJSONBody defines parameters for CreateCluster.
type CreateClusterJSONBody struct {
	// CloudProvider The cloud provider on which your TiDB cluster is hosted.
	// - `"AWS"`: the Amazon Web Services cloud provider
	// - `"GCP"`: the Google Cloud Platform cloud provider
	CloudProvider interface{} `json:"cloud_provider"`

	// ClusterType The cluster type.
	// - `"DEVELOPER"`: create a [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier) cluster
	// - `"DEDICATED"`: create a [Dedicated Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#dedicated-tier) cluster. Before creating a Dedicated Tier cluster, you must [set a Project CIDR](https://docs.pingcap.com/tidbcloud/set-up-vpc-peering-connections#prerequisite-set-a-project-cidr) on [TiDB Cloud console](https://tidbcloud.com/).
	ClusterType interface{} `json:"cluster_type"`

	// Config The configuration of the cluster.
	Config struct {
		// Components The components of the cluster.
		//
		// **Limitations**:
		// - For a Dedicated Tier cluster, the `components` parameter is **required**.
		// - For a Serverless Tier cluster, the `components` value is **ignored**. Setting this configuration does not have any effects.
		Components *struct {
			// Tidb The TiDB component of the cluster.
			Tidb struct {
				// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				NodeQuantity int32 `json:"node_quantity"`

				// NodeSize The size of the TiDB component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Additional combination rules**:
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
				NodeSize string `json:"node_size"`
			} `json:"tidb"`

			// Tiflash The TiFlash component of the cluster.
			Tiflash *struct {
				// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				NodeQuantity int32 `json:"node_quantity"`

				// NodeSize The size of the TiFlash component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Additional combination rules**:
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
				NodeSize string `json:"node_size"`

				// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				StorageSizeGib int32 `json:"storage_size_gib"`
			} `json:"tiflash,omitempty"`

			// Tikv The TiKV component of the cluster.
			Tikv struct {
				// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Limitations**:
				// - The `node_quantity` of TiKV must be a multiple of 3.
				NodeQuantity int32 `json:"node_quantity"`

				// NodeSize The size of the TiKV component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Additional combination rules**:
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
				NodeSize string `json:"node_size"`

				// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				StorageSizeGib int32 `json:"storage_size_gib"`
			} `json:"tikv"`
		} `json:"components,omitempty"`

		// IpAccessList A list of IP addresses and Classless Inter-Domain Routing (CIDR) addresses that are allowed to access the TiDB Cloud cluster via [standard connection](https://docs.pingcap.com/tidbcloud/connect-to-tidb-cluster#connect-via-standard-connection).
		IpAccessList *[]struct {
			// Cidr The IP address or CIDR range that you want to add to the cluster's IP access list.
			Cidr string `json:"cidr"`

			// Description Description that explains the purpose of the entry.
			Description *string `json:"description,omitempty"`
		} `json:"ip_access_list,omitempty"`

		// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
		//
		// **Limitations**:
		// - For a Serverless Tier cluster, only port `4000` is available.
		Port *int32 `json:"port,omitempty"`

		// RootPassword The root password to access the cluster. It must be 8-64 characters.
		RootPassword string `json:"root_password"`
	} `json:"config"`

	// Name The name of the cluster. The name must be 4-64 characters that can only include numbers, letters, and hyphens, and the first and last character must be a letter or number.
	Name string `json:"name"`

	// Region The region value should match the cloud provider's region code.
	// You can get the complete list of available regions from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
	//
	// For the detailed information on each region, refer to the documentation of the corresponding cloud provider ([AWS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html) | [GCP](https://cloud.google.com/about/locations#americas)).
	//
	// For example, if you want to deploy the cluster in the Oregon region for AWS, set the value to `"us-west-2"`.
	Region string `json:"region"`
}

// UpdateClusterJSONBody defines parameters for UpdateCluster.
type UpdateClusterJSONBody struct {
	// Config The configuration of the cluster. You can modify the components of the cluster using `components`, or pause or resume the cluster using `paused`.
	//
	//  You cannot change the cluster components and cluster status at the same time. That is, `components` and `paused` cannot be set at the same time.
	Config struct {
		// Components The components of the cluster.
		Components *struct {
			// Tidb The TiDB component of the cluster.
			Tidb *struct {
				// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				NodeQuantity *int32 `json:"node_quantity,omitempty"`

				// NodeSize The size of the TiDB component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Additional combination rules**:
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
				//
				// **Limitations**:
				// - See [Change node size](https://docs.pingcap.com/tidbcloud/scale-tidb-cluster#change-node-size).
				NodeSize *string `json:"node_size,omitempty"`
			} `json:"tidb,omitempty"`

			// Tiflash The TiFlash component of the cluster.
			//
			// If you want to add TiFlash nodes to a cluster that does not have one before (increase the node_quantity of `"TIFLASH"` from 0), you must specify the `node_size`, `storage_size_gib` and `node_quantity` of TiFlash nodes.
			Tiflash *struct {
				// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				NodeQuantity *int32 `json:"node_quantity,omitempty"`

				// NodeSize The size of the TiFlash component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Additional combination rules**:
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
				//
				// **Limitations**:
				// - See [Change node size](https://docs.pingcap.com/tidbcloud/scale-tidb-cluster#change-node-size).
				NodeSize *string `json:"node_size,omitempty"`

				// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Limitations**:
				// - You cannot decrease storage size for TiFlash.
				// - If your TiDB cluster is hosted by AWS, after changing the storage size of TiFlash, you must wait at least six hours before you can change it again.
				StorageSizeGib *int32 `json:"storage_size_gib,omitempty"`
			} `json:"tiflash,omitempty"`

			// Tikv The TiKV component of the cluster.
			Tikv *struct {
				// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Limitations**:
				// - The `node_quantity` of TiKV must be a multiple of 3.
				NodeQuantity *int32 `json:"node_quantity,omitempty"`

				// NodeSize The size of the TiKV component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Additional combination rules**:
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
				//
				// **Limitations**:
				// - See [Change node size](https://docs.pingcap.com/tidbcloud/scale-tidb-cluster#change-node-size).
				NodeSize *string `json:"node_size,omitempty"`

				// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Limitations**:
				// - You cannot decrease storage size for TiKV.
				// - If your TiDB cluster is hosted by AWS, after changing the storage size of TiKV, you must wait at least six hours before you can change it again.
				StorageSizeGib *int32 `json:"storage_size_gib,omitempty"`
			} `json:"tikv,omitempty"`
		} `json:"components,omitempty"`

		// Paused Flag that indicates whether the cluster is paused. `true` means to pause the cluster, and `false` means to resume the cluster. For more details, refer to [Pause or Resume a TiDB Cluster](https://docs.pingcap.com/tidbcloud/pause-or-resume-tidb-cluster).
		//
		// **Limitations:**
		//  - The cluster can be paused only when the `cluster_status` is `"AVAILABLE"`.
		// - The cluster can be resumed only when the `cluster_status` is `"PAUSED"`.
		Paused *bool `json:"paused,omitempty"`
	} `json:"config"`
}

// ListBackUpOfClusterParams defines parameters for ListBackUpOfCluster.
type ListBackUpOfClusterParams struct {
	// Page The number of pages.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The size of a page.
	PageSize *int32 `form:"page_size,omitempty" json:"page_size,omitempty"`
}

// CreateBackupJSONBody defines parameters for CreateBackup.
type CreateBackupJSONBody struct {
	// Description The description of the backup. It helps you add additional information to the backup. Allows up to 256 characters.
	Description *string `json:"description,omitempty"`

	// Name Specify the name for a manual backup. It is recommended that you use a unique name, so that it is easy to distinguish the backup when you query the backups.
	Name string `json:"name"`
}

// ListImportTasksParams defines parameters for ListImportTasks.
type ListImportTasksParams struct {
	// Page The number of pages.
	Page *int64 `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The size of a page.
	PageSize *int64 `form:"page_size,omitempty" json:"page_size,omitempty"`
}

// CreateImportTaskJSONBody defines parameters for CreateImportTask.
type CreateImportTaskJSONBody struct {
	// Name The name of an import task. The maximum length of the name is 64 characters.
	//
	// It is recommended that you use a unique name, so that you can easily identify the import task when you list all import tasks. If the name is not provided, a default name is generated with an `import_` prefix followed by a time string representing the creation time of the import task. For example, `import_2023-01-01T00:00:30Z`.
	Name *string `json:"name,omitempty"`

	// Options The additional options for creating an import task.
	Options *struct {
		// PreCreateTables The table definition of pre-created tables.
		//
		// **Note**: The name of the pre-created tables should match one of the target tables. Otherwise, the table will be ignored and won't be created
		PreCreateTables *[]struct {
			// DatabaseName The database name of the table.
			DatabaseName string `json:"database_name"`

			// Schema The schema for the table.
			Schema struct {
				// ColumnDefinitions The column definition for each column in the table.
				ColumnDefinitions []struct {
					// ColumnName The column name.
					ColumnName string `json:"column_name"`

					// ColumnType The column type.
					ColumnType string `json:"column_type"`
				} `json:"column_definitions"`

				// PrimaryKeyColumns The primary key column names for the table. This is optional. The primary key is taken into account when the table is pre-created before an import task is started.
				PrimaryKeyColumns *[]string `json:"primary_key_columns,omitempty"`
			} `json:"schema"`

			// TableName The table name of the table.
			TableName string `json:"table_name"`
		} `json:"pre_create_tables,omitempty"`
	} `json:"options,omitempty"`

	// Spec The specifications of the import task.
	Spec struct {
		// Source The data source settings of the import task.
		Source struct {
			// AwsAssumeRoleAccess The settings to access the S3 data by assuming a specific AWS role. This field is only needed if you need to access S3 data by assuming an AWS role.
			//
			// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
			AwsAssumeRoleAccess *struct {
				// AssumeRole The specific AWS role ARN that needs to be assumed to access the Amazon S3 data source.
				AssumeRole string `json:"assume_role"`
			} `json:"aws_assume_role_access,omitempty"`

			// AwsKeyAccess The settings to access the S3 data with an access key. This field is only needed if you want to access the S3 data with an access key.
			//
			// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
			AwsKeyAccess *struct {
				// AccessKeyId The access key ID of the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
				AccessKeyId string `json:"access_key_id"`

				// SecretAccessKey The secret access key for the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
				SecretAccessKey string `json:"secret_access_key"`
			} `json:"aws_key_access,omitempty"`

			// Format The format settings of the import data source.
			Format struct {
				// CsvConfig The CSV format settings to parse the source CSV files. This field is only needed if the source format is CSV.
				CsvConfig *struct {
					// BackslashEscape Whether a backslash (`\`) symbol followed by a character should be combined as a whole and treated as an escape sequence in a CSV field. For example, if this parameter is set to `true`, `\n` will be treated as a 'new-line' character. If it is set to `false`, `\n` will be treated as two separate characters: backslash and `n`.
					//
					// Currently, these are several supported escape sequences: `\0`, `\b`, `\n`, `\r`, `\t`, and `\Z`. If the parameter is set to `true`, but the backslash escape sequence is not recognized, the backslash character is ignored.
					BackslashEscape *bool `json:"backslash_escape,omitempty"`

					// Delimiter The delimiter character used to separate fields in the CSV data.
					Delimiter *string `json:"delimiter,omitempty"`

					// HasHeaderRow Whether the CSV data has a header row, which is not part of the data. If it is set to `true`, the import task will use the column names in the header row to match the column names in the target table.
					HasHeaderRow *bool `json:"has_header_row,omitempty"`

					// Quote The character used to quote the fields in the CSV data.
					Quote *string `json:"quote,omitempty"`
				} `json:"csv_config,omitempty"`

				// Type The format type of an import source.
				Type interface{} `json:"type"`
			} `json:"format"`

			// Type The data source type of an import task.
			//
			// - `"S3"`: import data from Amazon S3
			// - `"GCS"`: import data from Google Cloud Storage
			// - `"LOCAL_FILE"`: import data from a local file (only available for [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier-beta) clusters). Before you import from a local file, you need to first upload the file using the [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile) endpoint.
			Type interface{} `json:"type"`

			// Uri The data source URI of an import task. The URI scheme must match the data source type. Here are the scheme of each source type:
			// * `S3`: `s3://`
			// * `GCS`: `gs://`
			// * `LOCAL_FILE`: `file://`.
			//
			// **Note:** If the import source type is `LOCAL_FILE`, just provide the `upload_stub_id` of the uploaded file from the response of [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile), and make it as the data source folder. For example: `file://12345/`.
			//
			// **Limitation**: If the import source type is `LOCAL_FILE`, only the `CSV` source format type is supported.
			Uri string `json:"uri"`
		} `json:"source"`

		// Target The target settings of the import task.
		Target struct {
			// Tables The settings for each target table that is being imported for the import task.
			//
			// **Limitations:**
			// * Currently, if you want to use a custom filename pattern, you can only specify one table. If all the tables use the default filename pattern, you can specify more than one target table in `tables`.
			// * It is recommended that you pre-create the target tables before creating an import task. You can do this either by executing the `CREATE TABLE` statement in the cluster or by specifying the table definition in the table creation options.
			// * If a target table is not created, the import module tries to find a **TABLE SCHEMA FILE** containing the `CREATE TABLE` statement of the table in the data source folder with the name `${db_name}.${table_name}-schema.sql` (for example, `db01.tbl01-schema.sql`). If this file is found, the `CREATE TABLE` statement is automatically executed if the table doesn't exist before the actual import process starts. If the table is still missing after this pre-create step, an error will occur.
			Tables *[]struct {
				// DatabaseName The target database name.
				DatabaseName string `json:"database_name"`

				// FileNamePattern The filename pattern used to map the files in the data source to this target table. The pattern should be a simple glob pattern. Here are some examples:
				// * `my-data?.csv`: all CSV files starting with `my-data` and one character (such as `my-data1.csv` and `my-data2.csv`) will be imported into the same target table.
				// * `my-data*.csv`: all CSV files starting with `my-data` will be imported into the same target table.
				//
				// If no pattern is specified, a default pattern is used. The default pattern will try to find files with this naming convention as the data files for this table: `${db_name}.${table_name}.[numeric_index].${format_suffix}`.
				//
				// Here are some examples of filenames that can be matched as data files for the table `db01.table01`: `db01.table01.csv`, `db01.table01.00001.csv`.
				//
				// For more information about the custom file pattern and the default pattern, refer to [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
				//
				// **Note:** For `LOCAL_FILE` import tasks, use the local file name for this field. The local file name must match the local file name in [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile).
				FileNamePattern *string `json:"file_name_pattern,omitempty"`

				// TableName The target table name.
				TableName string `json:"table_name"`
			} `json:"tables,omitempty"`
		} `json:"target"`
	} `json:"spec"`
}

// PreviewImportDataJSONBody defines parameters for PreviewImportData.
type PreviewImportDataJSONBody struct {
	// LimitRowsCount The maximum number of rows to preview for each table.
	LimitRowsCount *int64 `json:"limit_rows_count,omitempty"`

	// Spec The specifications of the import task.
	Spec struct {
		// Source The data source settings of the import task.
		Source struct {
			// AwsAssumeRoleAccess The settings to access the S3 data by assuming a specific AWS role. This field is only needed if you need to access S3 data by assuming an AWS role.
			//
			// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
			AwsAssumeRoleAccess *struct {
				// AssumeRole The specific AWS role ARN that needs to be assumed to access the Amazon S3 data source.
				AssumeRole string `json:"assume_role"`
			} `json:"aws_assume_role_access,omitempty"`

			// AwsKeyAccess The settings to access the S3 data with an access key. This field is only needed if you want to access the S3 data with an access key.
			//
			// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
			AwsKeyAccess *struct {
				// AccessKeyId The access key ID of the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
				AccessKeyId string `json:"access_key_id"`

				// SecretAccessKey The secret access key for the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
				SecretAccessKey string `json:"secret_access_key"`
			} `json:"aws_key_access,omitempty"`

			// Format The format settings of the import data source.
			Format struct {
				// CsvConfig The CSV format settings to parse the source CSV files. This field is only needed if the source format is CSV.
				CsvConfig *struct {
					// BackslashEscape Whether a backslash (`\`) symbol followed by a character should be combined as a whole and treated as an escape sequence in a CSV field. For example, if this parameter is set to `true`, `\n` will be treated as a 'new-line' character. If it is set to `false`, `\n` will be treated as two separate characters: backslash and `n`.
					//
					// Currently, these are several supported escape sequences: `\0`, `\b`, `\n`, `\r`, `\t`, and `\Z`. If the parameter is set to `true`, but the backslash escape sequence is not recognized, the backslash character is ignored.
					BackslashEscape *bool `json:"backslash_escape,omitempty"`

					// Delimiter The delimiter character used to separate fields in the CSV data.
					Delimiter *string `json:"delimiter,omitempty"`

					// HasHeaderRow Whether the CSV data has a header row, which is not part of the data. If it is set to `true`, the import task will use the column names in the header row to match the column names in the target table.
					HasHeaderRow *bool `json:"has_header_row,omitempty"`

					// Quote The character used to quote the fields in the CSV data.
					Quote *string `json:"quote,omitempty"`
				} `json:"csv_config,omitempty"`

				// Type The format type of an import source.
				Type interface{} `json:"type"`
			} `json:"format"`

			// Type The data source type of an import task.
			//
			// - `"S3"`: import data from Amazon S3
			// - `"GCS"`: import data from Google Cloud Storage
			// - `"LOCAL_FILE"`: import data from a local file (only available for [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier-beta) clusters). Before you import from a local file, you need to first upload the file using the [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile) endpoint.
			Type interface{} `json:"type"`

			// Uri The data source URI of an import task. The URI scheme must match the data source type. Here are the scheme of each source type:
			// * `S3`: `s3://`
			// * `GCS`: `gs://`
			// * `LOCAL_FILE`: `file://`.
			//
			// **Note:** If the import source type is `LOCAL_FILE`, just provide the `upload_stub_id` of the uploaded file from the response of [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile), and make it as the data source folder. For example: `file://12345/`.
			//
			// **Limitation**: If the import source type is `LOCAL_FILE`, only the `CSV` source format type is supported.
			Uri string `json:"uri"`
		} `json:"source"`

		// Target The target settings of the import task.
		Target struct {
			// Tables The settings for each target table that is being imported for the import task.
			//
			// **Limitations:**
			// * Currently, if you want to use a custom filename pattern, you can only specify one table. If all the tables use the default filename pattern, you can specify more than one target table in `tables`.
			// * It is recommended that you pre-create the target tables before creating an import task. You can do this either by executing the `CREATE TABLE` statement in the cluster or by specifying the table definition in the table creation options.
			// * If a target table is not created, the import module tries to find a **TABLE SCHEMA FILE** containing the `CREATE TABLE` statement of the table in the data source folder with the name `${db_name}.${table_name}-schema.sql` (for example, `db01.tbl01-schema.sql`). If this file is found, the `CREATE TABLE` statement is automatically executed if the table doesn't exist before the actual import process starts. If the table is still missing after this pre-create step, an error will occur.
			Tables *[]struct {
				// DatabaseName The target database name.
				DatabaseName string `json:"database_name"`

				// FileNamePattern The filename pattern used to map the files in the data source to this target table. The pattern should be a simple glob pattern. Here are some examples:
				// * `my-data?.csv`: all CSV files starting with `my-data` and one character (such as `my-data1.csv` and `my-data2.csv`) will be imported into the same target table.
				// * `my-data*.csv`: all CSV files starting with `my-data` will be imported into the same target table.
				//
				// If no pattern is specified, a default pattern is used. The default pattern will try to find files with this naming convention as the data files for this table: `${db_name}.${table_name}.[numeric_index].${format_suffix}`.
				//
				// Here are some examples of filenames that can be matched as data files for the table `db01.table01`: `db01.table01.csv`, `db01.table01.00001.csv`.
				//
				// For more information about the custom file pattern and the default pattern, refer to [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
				//
				// **Note:** For `LOCAL_FILE` import tasks, use the local file name for this field. The local file name must match the local file name in [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile).
				FileNamePattern *string `json:"file_name_pattern,omitempty"`

				// TableName The target table name.
				TableName string `json:"table_name"`
			} `json:"tables,omitempty"`
		} `json:"target"`
	} `json:"spec"`
}

// UploadLocalFileJSONBody defines parameters for UploadLocalFile.
type UploadLocalFileJSONBody struct {
	// LocalFileName The local file name to be uploaded. Only CSV files are supported. The maximum length of the file name is 255 characters.
	//
	// **Note:**
	// * Provide only the basename of the file. For example, instead of specifying `/foo/bar/example_file.csv`, specify only `example_file.csv`. If you do specify a full file path, this endpoint will only use the basename as the file name.
	// * The directory name is not supported. For example: `/foobar/` is invalid.
	LocalFileName string `json:"local_file_name"`

	// Payload The payload to upload the local file content for an import task.
	Payload struct {
		// Content The base64-encoded content of the local file to be imported. The maximum size of the file should be 52428800 (50 MiB).
		//
		// **Note:** Before providing the content, process the file by taking the following steps:
		// 1. Compress the file using the **gzip** algorithm.
		// 2. Encode the compressed data using the **base64** algorithm.
		Content []byte `json:"content"`

		// TotalSizeBytes The total size of the **ACTUAL** local file contents, not the total size of the `content` field.
		//
		// The unit is byte, and the maximum value is `52428800` (50 MiB). If the given value of `total_size_bytes` exceeds the maximum value, an error will be reported.
		TotalSizeBytes string `json:"total_size_bytes"`
	} `json:"payload"`
}

// UpdateImportTaskJSONBody defines parameters for UpdateImportTask.
type UpdateImportTaskJSONBody struct {
	// Action The action to apply to the import task.
	//
	// **Limitation:**
	// Currently, only `CANCEL` is supported when the import task is in the `PREPARING` or `IMPORTING` phase, meaning that the import task will be cancelled.
	Action interface{} `json:"action"`
}

// ListRestoreTasksParams defines parameters for ListRestoreTasks.
type ListRestoreTasksParams struct {
	// Page The number of pages.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The size of a page.
	PageSize *int32 `form:"page_size,omitempty" json:"page_size,omitempty"`
}

// CreateRestoreTaskJSONBody defines parameters for CreateRestoreTask.
type CreateRestoreTaskJSONBody struct {
	// BackupId The ID of the backup.
	BackupId string `json:"backup_id"`

	// Config The configuration of the cluster.
	Config *struct {
		// Components The components of the cluster.
		//
		// **Limitations**:
		// - For a Dedicated Tier cluster, the `components` parameter is **required**.
		// - For a Serverless Tier cluster, the `components` value is **ignored**. Setting this configuration does not have any effects.
		Components *struct {
			// Tidb The TiDB component of the cluster.
			Tidb struct {
				// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				NodeQuantity int32 `json:"node_quantity"`

				// NodeSize The size of the TiDB component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Additional combination rules**:
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
				NodeSize string `json:"node_size"`
			} `json:"tidb"`

			// Tiflash The TiFlash component of the cluster.
			Tiflash *struct {
				// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				NodeQuantity int32 `json:"node_quantity"`

				// NodeSize The size of the TiFlash component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Additional combination rules**:
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
				NodeSize string `json:"node_size"`

				// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				StorageSizeGib int32 `json:"storage_size_gib"`
			} `json:"tiflash,omitempty"`

			// Tikv The TiKV component of the cluster.
			Tikv struct {
				// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Limitations**:
				// - The `node_quantity` of TiKV must be a multiple of 3.
				NodeQuantity int32 `json:"node_quantity"`

				// NodeSize The size of the TiKV component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// **Additional combination rules**:
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
				// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
				NodeSize string `json:"node_size"`

				// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				StorageSizeGib int32 `json:"storage_size_gib"`
			} `json:"tikv"`
		} `json:"components,omitempty"`

		// IpAccessList A list of IP addresses and Classless Inter-Domain Routing (CIDR) addresses that are allowed to access the TiDB Cloud cluster via [standard connection](https://docs.pingcap.com/tidbcloud/connect-to-tidb-cluster#connect-via-standard-connection).
		IpAccessList *[]struct {
			// Cidr The IP address or CIDR range that you want to add to the cluster's IP access list.
			Cidr string `json:"cidr"`

			// Description Description that explains the purpose of the entry.
			Description *string `json:"description,omitempty"`
		} `json:"ip_access_list,omitempty"`

		// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
		//
		// **Limitations**:
		// - For a Serverless Tier cluster, only port `4000` is available.
		Port *int32 `json:"port,omitempty"`

		// RootPassword The root password to access the cluster. It must be 8-64 characters.
		RootPassword string `json:"root_password"`
	} `json:"config,omitempty"`

	// Name The name of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
	//
	// - The name must be 4-64 characters that only contain numbers, letters, and hyphens. The first and last character must be a letter or number.
	// - This must be different from the name of the existing cluster.
	Name string `json:"name"`
}

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody CreateProjectJSONBody

// CreateAwsCmekJSONRequestBody defines body for CreateAwsCmek for application/json ContentType.
type CreateAwsCmekJSONRequestBody CreateAwsCmekJSONBody

// CreateClusterJSONRequestBody defines body for CreateCluster for application/json ContentType.
type CreateClusterJSONRequestBody CreateClusterJSONBody

// UpdateClusterJSONRequestBody defines body for UpdateCluster for application/json ContentType.
type UpdateClusterJSONRequestBody UpdateClusterJSONBody

// CreateBackupJSONRequestBody defines body for CreateBackup for application/json ContentType.
type CreateBackupJSONRequestBody CreateBackupJSONBody

// CreateImportTaskJSONRequestBody defines body for CreateImportTask for application/json ContentType.
type CreateImportTaskJSONRequestBody CreateImportTaskJSONBody

// PreviewImportDataJSONRequestBody defines body for PreviewImportData for application/json ContentType.
type PreviewImportDataJSONRequestBody PreviewImportDataJSONBody

// UploadLocalFileJSONRequestBody defines body for UploadLocalFile for application/json ContentType.
type UploadLocalFileJSONRequestBody UploadLocalFileJSONBody

// UpdateImportTaskJSONRequestBody defines body for UpdateImportTask for application/json ContentType.
type UpdateImportTaskJSONRequestBody UpdateImportTaskJSONBody

// CreateRestoreTaskJSONRequestBody defines body for CreateRestoreTask for application/json ContentType.
type CreateRestoreTaskJSONRequestBody CreateRestoreTaskJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListProviderRegions request
	ListProviderRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjects request
	ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProject request with any body
	CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAwsCmek request
	ListAwsCmek(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAwsCmek request with any body
	CreateAwsCmekWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAwsCmek(ctx context.Context, projectId string, body CreateAwsCmekJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClustersOfProject request
	ListClustersOfProject(ctx context.Context, projectId string, params *ListClustersOfProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCluster request with any body
	CreateClusterWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCluster(ctx context.Context, projectId string, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, projectId string, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, projectId string, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCluster request with any body
	UpdateClusterWithBody(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCluster(ctx context.Context, projectId string, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBackUpOfCluster request
	ListBackUpOfCluster(ctx context.Context, projectId string, clusterId string, params *ListBackUpOfClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBackup request with any body
	CreateBackupWithBody(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBackup(ctx context.Context, projectId string, clusterId string, body CreateBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackup request
	DeleteBackup(ctx context.Context, projectId string, clusterId string, backupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackupOfCluster request
	GetBackupOfCluster(ctx context.Context, projectId string, clusterId string, backupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListImportTasks request
	ListImportTasks(ctx context.Context, projectId string, clusterId string, params *ListImportTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImportTask request with any body
	CreateImportTaskWithBody(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateImportTask(ctx context.Context, projectId string, clusterId string, body CreateImportTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewImportData request with any body
	PreviewImportDataWithBody(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreviewImportData(ctx context.Context, projectId string, clusterId string, body PreviewImportDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImportTaskRoleInfo request
	GetImportTaskRoleInfo(ctx context.Context, projectId string, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadLocalFile request with any body
	UploadLocalFileWithBody(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadLocalFile(ctx context.Context, projectId string, clusterId string, body UploadLocalFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImportTask request
	GetImportTask(ctx context.Context, projectId string, clusterId string, importId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateImportTask request with any body
	UpdateImportTaskWithBody(ctx context.Context, projectId string, clusterId string, importId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateImportTask(ctx context.Context, projectId string, clusterId string, importId string, body UpdateImportTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRestoreTasks request
	ListRestoreTasks(ctx context.Context, projectId string, params *ListRestoreTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRestoreTask request with any body
	CreateRestoreTaskWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRestoreTask(ctx context.Context, projectId string, body CreateRestoreTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRestoreTask request
	GetRestoreTask(ctx context.Context, projectId string, restoreId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListProviderRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProviderRegionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) ListAwsCmek(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAwsCmekRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) CreateAwsCmekWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAwsCmekRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) CreateAwsCmek(ctx context.Context, projectId string, body CreateAwsCmekJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAwsCmekRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) ListClustersOfProject(ctx context.Context, projectId string, params *ListClustersOfProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClustersOfProjectRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) CreateCluster(ctx context.Context, projectId string, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) DeleteCluster(ctx context.Context, projectId string, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) GetCluster(ctx context.Context, projectId string, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) UpdateCluster(ctx context.Context, projectId string, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequest(c.Server, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) ListBackUpOfCluster(ctx context.Context, projectId string, clusterId string, params *ListBackUpOfClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBackUpOfClusterRequest(c.Server, projectId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) CreateBackupWithBody(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackupRequestWithBody(c.Server, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) CreateBackup(ctx context.Context, projectId string, clusterId string, body CreateBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackupRequest(c.Server, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) DeleteBackup(ctx context.Context, projectId string, clusterId string, backupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackupRequest(c.Server, projectId, clusterId, backupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) GetBackupOfCluster(ctx context.Context, projectId string, clusterId string, backupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupOfClusterRequest(c.Server, projectId, clusterId, backupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) ListImportTasks(ctx context.Context, projectId string, clusterId string, params *ListImportTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListImportTasksRequest(c.Server, projectId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) CreateImportTaskWithBody(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImportTaskRequestWithBody(c.Server, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) CreateImportTask(ctx context.Context, projectId string, clusterId string, body CreateImportTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImportTaskRequest(c.Server, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) PreviewImportDataWithBody(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewImportDataRequestWithBody(c.Server, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) PreviewImportData(ctx context.Context, projectId string, clusterId string, body PreviewImportDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewImportDataRequest(c.Server, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) GetImportTaskRoleInfo(ctx context.Context, projectId string, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImportTaskRoleInfoRequest(c.Server, projectId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) UploadLocalFileWithBody(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadLocalFileRequestWithBody(c.Server, projectId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) UploadLocalFile(ctx context.Context, projectId string, clusterId string, body UploadLocalFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadLocalFileRequest(c.Server, projectId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) GetImportTask(ctx context.Context, projectId string, clusterId string, importId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImportTaskRequest(c.Server, projectId, clusterId, importId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) UpdateImportTaskWithBody(ctx context.Context, projectId string, clusterId string, importId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImportTaskRequestWithBody(c.Server, projectId, clusterId, importId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) UpdateImportTask(ctx context.Context, projectId string, clusterId string, importId string, body UpdateImportTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImportTaskRequest(c.Server, projectId, clusterId, importId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) ListRestoreTasks(ctx context.Context, projectId string, params *ListRestoreTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRestoreTasksRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) CreateRestoreTaskWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRestoreTaskRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) CreateRestoreTask(ctx context.Context, projectId string, body CreateRestoreTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRestoreTaskRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

func (c *Client) GetRestoreTask(ctx context.Context, projectId string, restoreId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRestoreTaskRequest(c.Server, projectId, restoreId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	// return c.Client.Do(req)
    return c.AddDigestHeader(req)
}

// NewListProviderRegionsRequest generates requests for ListProviderRegions
func NewListProviderRegionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/clusters/provider/regions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectsRequest generates requests for ListProjects
func NewListProjectsRequest(server string, params *ListProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRequest calls the generic CreateProject builder with application/json body
func NewCreateProjectRequest(server string, body CreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProjectRequestWithBody generates requests for CreateProject with any type of body
func NewCreateProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAwsCmekRequest generates requests for ListAwsCmek
func NewListAwsCmekRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/aws-cmek", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAwsCmekRequest calls the generic CreateAwsCmek builder with application/json body
func NewCreateAwsCmekRequest(server string, projectId string, body CreateAwsCmekJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAwsCmekRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewCreateAwsCmekRequestWithBody generates requests for CreateAwsCmek with any type of body
func NewCreateAwsCmekRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/aws-cmek", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListClustersOfProjectRequest generates requests for ListClustersOfProject
func NewListClustersOfProjectRequest(server string, projectId string, params *ListClustersOfProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterRequest calls the generic CreateCluster builder with application/json body
func NewCreateClusterRequest(server string, projectId string, body CreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, projectId string, clusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, projectId string, clusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequest calls the generic UpdateCluster builder with application/json body
func NewUpdateClusterRequest(server string, projectId string, clusterId string, body UpdateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterRequestWithBody(server, projectId, clusterId, "application/json", bodyReader)
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, projectId string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBackUpOfClusterRequest generates requests for ListBackUpOfCluster
func NewListBackUpOfClusterRequest(server string, projectId string, clusterId string, params *ListBackUpOfClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s/backups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBackupRequest calls the generic CreateBackup builder with application/json body
func NewCreateBackupRequest(server string, projectId string, clusterId string, body CreateBackupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBackupRequestWithBody(server, projectId, clusterId, "application/json", bodyReader)
}

// NewCreateBackupRequestWithBody generates requests for CreateBackup with any type of body
func NewCreateBackupRequestWithBody(server string, projectId string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s/backups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBackupRequest generates requests for DeleteBackup
func NewDeleteBackupRequest(server string, projectId string, clusterId string, backupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "backup_id", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s/backups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackupOfClusterRequest generates requests for GetBackupOfCluster
func NewGetBackupOfClusterRequest(server string, projectId string, clusterId string, backupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "backup_id", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s/backups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListImportTasksRequest generates requests for ListImportTasks
func NewListImportTasksRequest(server string, projectId string, clusterId string, params *ListImportTasksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s/imports", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateImportTaskRequest calls the generic CreateImportTask builder with application/json body
func NewCreateImportTaskRequest(server string, projectId string, clusterId string, body CreateImportTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateImportTaskRequestWithBody(server, projectId, clusterId, "application/json", bodyReader)
}

// NewCreateImportTaskRequestWithBody generates requests for CreateImportTask with any type of body
func NewCreateImportTaskRequestWithBody(server string, projectId string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s/imports", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPreviewImportDataRequest calls the generic PreviewImportData builder with application/json body
func NewPreviewImportDataRequest(server string, projectId string, clusterId string, body PreviewImportDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreviewImportDataRequestWithBody(server, projectId, clusterId, "application/json", bodyReader)
}

// NewPreviewImportDataRequestWithBody generates requests for PreviewImportData with any type of body
func NewPreviewImportDataRequestWithBody(server string, projectId string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s/imports/preview", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetImportTaskRoleInfoRequest generates requests for GetImportTaskRoleInfo
func NewGetImportTaskRoleInfoRequest(server string, projectId string, clusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s/imports/role_info", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadLocalFileRequest calls the generic UploadLocalFile builder with application/json body
func NewUploadLocalFileRequest(server string, projectId string, clusterId string, body UploadLocalFileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadLocalFileRequestWithBody(server, projectId, clusterId, "application/json", bodyReader)
}

// NewUploadLocalFileRequestWithBody generates requests for UploadLocalFile with any type of body
func NewUploadLocalFileRequestWithBody(server string, projectId string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s/imports/upload_file", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetImportTaskRequest generates requests for GetImportTask
func NewGetImportTaskRequest(server string, projectId string, clusterId string, importId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "import_id", runtime.ParamLocationPath, importId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s/imports/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateImportTaskRequest calls the generic UpdateImportTask builder with application/json body
func NewUpdateImportTaskRequest(server string, projectId string, clusterId string, importId string, body UpdateImportTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateImportTaskRequestWithBody(server, projectId, clusterId, importId, "application/json", bodyReader)
}

// NewUpdateImportTaskRequestWithBody generates requests for UpdateImportTask with any type of body
func NewUpdateImportTaskRequestWithBody(server string, projectId string, clusterId string, importId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "import_id", runtime.ParamLocationPath, importId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/clusters/%s/imports/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRestoreTasksRequest generates requests for ListRestoreTasks
func NewListRestoreTasksRequest(server string, projectId string, params *ListRestoreTasksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/restores", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRestoreTaskRequest calls the generic CreateRestoreTask builder with application/json body
func NewCreateRestoreTaskRequest(server string, projectId string, body CreateRestoreTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRestoreTaskRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewCreateRestoreTaskRequestWithBody generates requests for CreateRestoreTask with any type of body
func NewCreateRestoreTaskRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/restores", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRestoreTaskRequest generates requests for GetRestoreTask
func NewGetRestoreTaskRequest(server string, projectId string, restoreId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "restore_id", runtime.ParamLocationPath, restoreId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1beta/projects/%s/restores/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListProviderRegions request
	ListProviderRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListProviderRegionsResponse, error)

	// ListProjects request
	ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error)

	// CreateProject request with any body
	CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	// ListAwsCmek request
	ListAwsCmekWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ListAwsCmekResponse, error)

	// CreateAwsCmek request with any body
	CreateAwsCmekWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAwsCmekResponse, error)

	CreateAwsCmekWithResponse(ctx context.Context, projectId string, body CreateAwsCmekJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAwsCmekResponse, error)

	// ListClustersOfProject request
	ListClustersOfProjectWithResponse(ctx context.Context, projectId string, params *ListClustersOfProjectParams, reqEditors ...RequestEditorFn) (*ListClustersOfProjectResponse, error)

	// CreateCluster request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	CreateClusterWithResponse(ctx context.Context, projectId string, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// DeleteCluster request
	DeleteClusterWithResponse(ctx context.Context, projectId string, clusterId string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetCluster request
	GetClusterWithResponse(ctx context.Context, projectId string, clusterId string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateCluster request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	UpdateClusterWithResponse(ctx context.Context, projectId string, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// ListBackUpOfCluster request
	ListBackUpOfClusterWithResponse(ctx context.Context, projectId string, clusterId string, params *ListBackUpOfClusterParams, reqEditors ...RequestEditorFn) (*ListBackUpOfClusterResponse, error)

	// CreateBackup request with any body
	CreateBackupWithBodyWithResponse(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackupResponse, error)

	CreateBackupWithResponse(ctx context.Context, projectId string, clusterId string, body CreateBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackupResponse, error)

	// DeleteBackup request
	DeleteBackupWithResponse(ctx context.Context, projectId string, clusterId string, backupId string, reqEditors ...RequestEditorFn) (*DeleteBackupResponse, error)

	// GetBackupOfCluster request
	GetBackupOfClusterWithResponse(ctx context.Context, projectId string, clusterId string, backupId string, reqEditors ...RequestEditorFn) (*GetBackupOfClusterResponse, error)

	// ListImportTasks request
	ListImportTasksWithResponse(ctx context.Context, projectId string, clusterId string, params *ListImportTasksParams, reqEditors ...RequestEditorFn) (*ListImportTasksResponse, error)

	// CreateImportTask request with any body
	CreateImportTaskWithBodyWithResponse(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImportTaskResponse, error)

	CreateImportTaskWithResponse(ctx context.Context, projectId string, clusterId string, body CreateImportTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImportTaskResponse, error)

	// PreviewImportData request with any body
	PreviewImportDataWithBodyWithResponse(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewImportDataResponse, error)

	PreviewImportDataWithResponse(ctx context.Context, projectId string, clusterId string, body PreviewImportDataJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewImportDataResponse, error)

	// GetImportTaskRoleInfo request
	GetImportTaskRoleInfoWithResponse(ctx context.Context, projectId string, clusterId string, reqEditors ...RequestEditorFn) (*GetImportTaskRoleInfoResponse, error)

	// UploadLocalFile request with any body
	UploadLocalFileWithBodyWithResponse(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLocalFileResponse, error)

	UploadLocalFileWithResponse(ctx context.Context, projectId string, clusterId string, body UploadLocalFileJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadLocalFileResponse, error)

	// GetImportTask request
	GetImportTaskWithResponse(ctx context.Context, projectId string, clusterId string, importId string, reqEditors ...RequestEditorFn) (*GetImportTaskResponse, error)

	// UpdateImportTask request with any body
	UpdateImportTaskWithBodyWithResponse(ctx context.Context, projectId string, clusterId string, importId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImportTaskResponse, error)

	UpdateImportTaskWithResponse(ctx context.Context, projectId string, clusterId string, importId string, body UpdateImportTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImportTaskResponse, error)

	// ListRestoreTasks request
	ListRestoreTasksWithResponse(ctx context.Context, projectId string, params *ListRestoreTasksParams, reqEditors ...RequestEditorFn) (*ListRestoreTasksResponse, error)

	// CreateRestoreTask request with any body
	CreateRestoreTaskWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRestoreTaskResponse, error)

	CreateRestoreTaskWithResponse(ctx context.Context, projectId string, body CreateRestoreTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRestoreTaskResponse, error)

	// GetRestoreTask request
	GetRestoreTaskWithResponse(ctx context.Context, projectId string, restoreId string, reqEditors ...RequestEditorFn) (*GetRestoreTaskResponse, error)
}

type ListProviderRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Items Items of provider regions.
		Items *[]struct {
			// CloudProvider The cloud provider on which your TiDB cluster is hosted.
			// - `"AWS"`: the Amazon Web Services cloud provider
			// - `"GCP"`: the Google Cloud Platform cloud provider
			CloudProvider *interface{} `json:"cloud_provider,omitempty"`

			// ClusterType The cluster type.
			// - `"DEVELOPER"`: a [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier) cluster
			// - `"DEDICATED"`: a [Dedicated Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#dedicated-tier) cluster
			//
			// **Warning:** `"DEVELOPER"` will soon be changed to `"SERVERLESS"` to represent Serverless Tier clusters.
			ClusterType *interface{} `json:"cluster_type,omitempty"`

			// Region The region in which your TiDB cluster is hosted.
			//
			// For the detailed information on each region, refer to the documentation of the corresponding cloud provider ([AWS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html) | [GCP](https://cloud.google.com/about/locations#americas)).
			//
			// For example, `"us-west-2"` refers to Oregon for AWS.
			Region *string `json:"region,omitempty"`

			// Tidb The list of TiDB specifications in the region.
			Tidb *[]struct {
				// NodeQuantityRange The range and step of node quantity of the TiDB component in the cluster.
				NodeQuantityRange *struct {
					// Min The minimum node quantity of the component in the cluster.
					Min *int32 `json:"min,omitempty"`

					// Step The step of node quantity of the component in the cluster.
					Step *int32 `json:"step,omitempty"`
				} `json:"node_quantity_range,omitempty"`

				// NodeSize The size of the TiDB component in the cluster.
				NodeSize *string `json:"node_size,omitempty"`
			} `json:"tidb,omitempty"`

			// Tiflash The list of TiFlash specifications in the region.
			Tiflash *[]struct {
				// NodeQuantityRange The range and step of node quantity of the TiFlash component in the cluster.
				NodeQuantityRange *struct {
					// Min The minimum node quantity of the component in the cluster.
					Min *int32 `json:"min,omitempty"`

					// Step The step of node quantity of the component in the cluster.
					Step *int32 `json:"step,omitempty"`
				} `json:"node_quantity_range,omitempty"`

				// NodeSize The size of the TiFlash component in the cluster.
				NodeSize *string `json:"node_size,omitempty"`

				// StorageSizeGibRange The storage size range for each node of the TiFlash component in the cluster.
				StorageSizeGibRange *struct {
					// Max The maximum storage size for each node of the component in the cluster.
					Max *int32 `json:"max,omitempty"`

					// Min The minimum storage size for each node of the component in the cluster.
					Min *int32 `json:"min,omitempty"`
				} `json:"storage_size_gib_range,omitempty"`
			} `json:"tiflash,omitempty"`

			// Tikv The list of TiKV specifications in the region.
			Tikv *[]struct {
				// NodeQuantityRange The range and step of node quantity of the TiKV component in the cluster.
				NodeQuantityRange *struct {
					// Min The minimum node quantity of the component in the cluster.
					Min *int32 `json:"min,omitempty"`

					// Step The step of node quantity of the component in the cluster.
					Step *int32 `json:"step,omitempty"`
				} `json:"node_quantity_range,omitempty"`

				// NodeSize The size of the TiKV component in the cluster.
				NodeSize *string `json:"node_size,omitempty"`

				// StorageSizeGibRange The storage size range for each node of the TiKV component in the cluster.
				StorageSizeGibRange *struct {
					// Max The maximum storage size for each node of the component in the cluster.
					Max *int32 `json:"max,omitempty"`

					// Min The minimum storage size for each node of the component in the cluster.
					Min *int32 `json:"min,omitempty"`
				} `json:"storage_size_gib_range,omitempty"`
			} `json:"tikv,omitempty"`
		} `json:"items,omitempty"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListProviderRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProviderRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Items The items of accessible projects.
		Items []struct {
			// AwsCmekEnabled Flag that indicates whether to enable AWS Customer-Managed Encryption Keys (CMEK). For more information, see [Encryption at Rest using CMEK](https://docs.pingcap.com/tidbcloud/tidb-cloud-encrypt-cmek).
			//
			// **Note:** Currently, this feature is only available upon request. If you need to try out this feature, contact [support](https://docs.pingcap.com/tidbcloud/tidb-cloud-support).
			AwsCmekEnabled *bool `json:"aws_cmek_enabled,omitempty"`

			// ClusterCount The number of TiDB Cloud clusters deployed in the project.
			ClusterCount *int64 `json:"cluster_count,omitempty"`

			// CreateTimestamp The creation time of the cluster in Unix timestamp seconds (epoch time).
			CreateTimestamp *string `json:"create_timestamp,omitempty"`

			// Id The ID of the project.
			Id *string `json:"id,omitempty"`

			// Name The name of the project.
			Name *string `json:"name,omitempty"`

			// OrgId The ID of the TiDB Cloud organization to which the project belongs.
			OrgId *string `json:"org_id,omitempty"`

			// UserCount The number of users in the project.
			UserCount *int64 `json:"user_count,omitempty"`
		} `json:"items"`

		// Total The total number of accessible projects.
		Total int64 `json:"total"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the project.
		Id string `json:"id"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAwsCmekResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Items The specifications of the AWS CMEK.
		Items *[]struct {
			// KmsArn The KMS ARN of the AWS CMEK.
			KmsArn string `json:"kms_arn"`

			// Region The region name of the AWS CMEK. The region value should match the cloud provider's region code.
			//
			// You can get the complete list of available regions from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
			//
			// For the detailed information on each region, refer to the documentation of the [AWS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html) cloud provider.
			Region string `json:"region"`
		} `json:"items,omitempty"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAwsCmekResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAwsCmekResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAwsCmekResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAwsCmekResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAwsCmekResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClustersOfProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Items The items of clusters in the project.
		Items []struct {
			// CloudProvider The cloud provider on which your TiDB cluster is hosted.
			// - `"AWS"`: the Amazon Web Services cloud provider
			// - `"GCP"`: the Google Cloud Platform cloud provider
			CloudProvider *interface{} `json:"cloud_provider,omitempty"`

			// ClusterType The cluster type:
			// - `"DEVELOPER"`: a [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier) cluster
			// - `"DEDICATED"`: a [Dedicated Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#dedicated-tier) cluster
			//
			// **Warning:** `"DEVELOPER"` will soon be changed to `"SERVERLESS"` to represent Serverless Tier clusters.
			ClusterType *interface{} `json:"cluster_type,omitempty"`

			// Config The configuration of the cluster.
			Config *struct {
				// Components The components of the cluster.
				Components *struct {
					// Tidb The TiDB component of the cluster.
					Tidb struct {
						// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						NodeQuantity int32 `json:"node_quantity"`

						// NodeSize The size of the TiDB component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						//
						// **Additional combination rules**:
						// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
						// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
						NodeSize string `json:"node_size"`
					} `json:"tidb"`

					// Tiflash The TiFlash component of the cluster.
					Tiflash *struct {
						// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						NodeQuantity int32 `json:"node_quantity"`

						// NodeSize The size of the TiFlash component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						//
						// **Additional combination rules**:
						// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
						// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
						NodeSize string `json:"node_size"`

						// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						StorageSizeGib int32 `json:"storage_size_gib"`
					} `json:"tiflash,omitempty"`

					// Tikv The TiKV component of the cluster.
					Tikv struct {
						// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						//
						// **Limitations**:
						// - The `node_quantity` of TiKV must be a multiple of 3.
						NodeQuantity int32 `json:"node_quantity"`

						// NodeSize The size of the TiKV component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						//
						// **Additional combination rules**:
						// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
						// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
						NodeSize string `json:"node_size"`

						// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						StorageSizeGib int32 `json:"storage_size_gib"`
					} `json:"tikv"`
				} `json:"components,omitempty"`

				// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
				Port *int32 `json:"port,omitempty"`
			} `json:"config,omitempty"`

			// CreateTimestamp The creation time of the cluster in Unix timestamp seconds (epoch time).
			CreateTimestamp *string `json:"create_timestamp,omitempty"`

			// Id The ID of the cluster.
			Id string `json:"id"`

			// Name The name of the cluster.
			Name *string `json:"name,omitempty"`

			// ProjectId The ID of the project.
			ProjectId string `json:"project_id"`

			// Region Region of the cluster.
			Region *string `json:"region,omitempty"`

			// Status The status of the cluster.
			Status *struct {
				// ClusterStatus Status of the cluster.
				ClusterStatus *interface{} `json:"cluster_status,omitempty"`

				// ConnectionStrings Connection strings.
				ConnectionStrings *struct {
					// DefaultUser The default TiDB user for connection.
					DefaultUser *string `json:"default_user,omitempty"`

					// Standard Standard connection string.
					//
					// You must configure the [IP Access List](https://docs.pingcap.com/tidbcloud/connect-to-tidb-cluster#connect-via-standard-connection) for the cluster you created on [TiDB Cloud console](https://tidbcloud.com/) before connecting to this connection string.
					Standard *struct {
						// Host The host of standard connection.
						Host *string `json:"host,omitempty"`

						// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
						//
						// **Limitations**:
						// - For a Serverless Tier cluster, only port `4000` is available.
						Port *int32 `json:"port,omitempty"`
					} `json:"standard,omitempty"`

					// VpcPeering [VPC peering](https://docs.pingcap.com/tidbcloud/tidb-cloud-glossary#vpc-peering) connection string.
					//
					// You must [Set up VPC peering connections](https://docs.pingcap.com/tidbcloud/set-up-vpc-peering-connections) for the project before connecting to this private connection string.
					VpcPeering *struct {
						// Host The host of VPC peering connection.
						Host *string `json:"host,omitempty"`

						// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
						//
						// **Limitations**:
						// - For a Serverless Tier cluster, only port `4000` is available.
						Port *int32 `json:"port,omitempty"`
					} `json:"vpc_peering,omitempty"`
				} `json:"connection_strings,omitempty"`

				// NodeMap Node map. The `node_map` is returned only when the `cluster_status` is `"AVAILABLE"` or `"MODIFYING"`.
				NodeMap *struct {
					// Tidb TiDB node map.
					Tidb []struct {
						// AvailabilityZone The availability zone of a node in the cluster.
						AvailabilityZone *string `json:"availability_zone,omitempty"`

						// NodeName The name of a node in the cluster.
						NodeName *string `json:"node_name,omitempty"`

						// NodeSize The size of the TiDB component in the cluster.
						NodeSize *string `json:"node_size,omitempty"`

						// RamBytes The RAM size of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `ram_bytes` is always 0.
						RamBytes *string `json:"ram_bytes,omitempty"`

						// Status The status of a node in the cluster.
						Status *interface{} `json:"status,omitempty"`

						// VcpuNum The total vCPUs of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `vcpu_num` is always 0.
						VcpuNum *int32 `json:"vcpu_num,omitempty"`
					} `json:"tidb"`

					// Tiflash TiFlash node map.
					Tiflash *[]struct {
						// AvailabilityZone The availability zone of a node in the cluster.
						AvailabilityZone *string `json:"availability_zone,omitempty"`

						// NodeName The name of a node in the cluster.
						NodeName *string `json:"node_name,omitempty"`

						// NodeSize The size of the TiFlash component in the cluster.
						NodeSize *string `json:"node_size,omitempty"`

						// RamBytes The RAM size of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `ram_bytes` is always 0.
						RamBytes *string `json:"ram_bytes,omitempty"`

						// Status The status of a node in the cluster.
						Status *interface{} `json:"status,omitempty"`

						// StorageSizeGib The storage size of a node in the cluster.
						StorageSizeGib *int32 `json:"storage_size_gib,omitempty"`

						// VcpuNum The total vCPUs of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `vcpu_num` is always 0.
						VcpuNum *int32 `json:"vcpu_num,omitempty"`
					} `json:"tiflash,omitempty"`

					// Tikv TiKV node map.
					Tikv []struct {
						// AvailabilityZone The availability zone of a node in the cluster.
						AvailabilityZone *string `json:"availability_zone,omitempty"`

						// NodeName The name of a node in the cluster.
						NodeName *string `json:"node_name,omitempty"`

						// NodeSize The size of the TiKV component in the cluster.
						NodeSize *string `json:"node_size,omitempty"`

						// RamBytes The RAM size of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `ram_bytes` is always 0.
						RamBytes *string `json:"ram_bytes,omitempty"`

						// Status The status of a node in the cluster.
						Status *interface{} `json:"status,omitempty"`

						// StorageSizeGib The storage size of a node in the cluster.
						StorageSizeGib *int32 `json:"storage_size_gib,omitempty"`

						// VcpuNum The total vCPUs of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `vcpu_num` is always 0.
						VcpuNum *int32 `json:"vcpu_num,omitempty"`
					} `json:"tikv"`
				} `json:"node_map,omitempty"`

				// TidbVersion TiDB version.
				TidbVersion *string `json:"tidb_version,omitempty"`
			} `json:"status,omitempty"`
		} `json:"items"`

		// Total The total number of clusters in the project.
		Total int64 `json:"total"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListClustersOfProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClustersOfProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the cluster.
		Id string `json:"id"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CloudProvider The cloud provider on which your TiDB cluster is hosted.
		// - `"AWS"`: the Amazon Web Services cloud provider
		// - `"GCP"`: the Google Cloud Platform cloud provider
		CloudProvider *interface{} `json:"cloud_provider,omitempty"`

		// ClusterType The cluster type:
		// - `"DEVELOPER"`: a [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier) cluster
		// - `"DEDICATED"`: a [Dedicated Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#dedicated-tier) cluster
		//
		// **Warning:** `"DEVELOPER"` will soon be changed to `"SERVERLESS"` to represent Serverless Tier clusters.
		ClusterType *interface{} `json:"cluster_type,omitempty"`

		// Config The configuration of the cluster.
		Config *struct {
			// Components The components of the cluster.
			Components *struct {
				// Tidb The TiDB component of the cluster.
				Tidb struct {
					// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
					NodeQuantity int32 `json:"node_quantity"`

					// NodeSize The size of the TiDB component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
					//
					// **Additional combination rules**:
					// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
					// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
					NodeSize string `json:"node_size"`
				} `json:"tidb"`

				// Tiflash The TiFlash component of the cluster.
				Tiflash *struct {
					// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
					NodeQuantity int32 `json:"node_quantity"`

					// NodeSize The size of the TiFlash component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
					//
					// **Additional combination rules**:
					// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
					// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
					NodeSize string `json:"node_size"`

					// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
					StorageSizeGib int32 `json:"storage_size_gib"`
				} `json:"tiflash,omitempty"`

				// Tikv The TiKV component of the cluster.
				Tikv struct {
					// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
					//
					// **Limitations**:
					// - The `node_quantity` of TiKV must be a multiple of 3.
					NodeQuantity int32 `json:"node_quantity"`

					// NodeSize The size of the TiKV component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
					//
					// **Additional combination rules**:
					// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
					// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
					NodeSize string `json:"node_size"`

					// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
					StorageSizeGib int32 `json:"storage_size_gib"`
				} `json:"tikv"`
			} `json:"components,omitempty"`

			// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
			Port *int32 `json:"port,omitempty"`
		} `json:"config,omitempty"`

		// CreateTimestamp The creation time of the cluster in Unix timestamp seconds (epoch time).
		CreateTimestamp *string `json:"create_timestamp,omitempty"`

		// Id The ID of the cluster.
		Id string `json:"id"`

		// Name The name of the cluster.
		Name *string `json:"name,omitempty"`

		// ProjectId The ID of the project.
		ProjectId string `json:"project_id"`

		// Region Region of the cluster.
		Region *string `json:"region,omitempty"`

		// Status The status of the cluster.
		Status *struct {
			// ClusterStatus Status of the cluster.
			ClusterStatus *interface{} `json:"cluster_status,omitempty"`

			// ConnectionStrings Connection strings.
			ConnectionStrings *struct {
				// DefaultUser The default TiDB user for connection.
				DefaultUser *string `json:"default_user,omitempty"`

				// Standard Standard connection string.
				//
				// You must configure the [IP Access List](https://docs.pingcap.com/tidbcloud/connect-to-tidb-cluster#connect-via-standard-connection) for the cluster you created on [TiDB Cloud console](https://tidbcloud.com/) before connecting to this connection string.
				Standard *struct {
					// Host The host of standard connection.
					Host *string `json:"host,omitempty"`

					// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
					//
					// **Limitations**:
					// - For a Serverless Tier cluster, only port `4000` is available.
					Port *int32 `json:"port,omitempty"`
				} `json:"standard,omitempty"`

				// VpcPeering [VPC peering](https://docs.pingcap.com/tidbcloud/tidb-cloud-glossary#vpc-peering) connection string.
				//
				// You must [Set up VPC peering connections](https://docs.pingcap.com/tidbcloud/set-up-vpc-peering-connections) for the project before connecting to this private connection string.
				VpcPeering *struct {
					// Host The host of VPC peering connection.
					Host *string `json:"host,omitempty"`

					// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
					//
					// **Limitations**:
					// - For a Serverless Tier cluster, only port `4000` is available.
					Port *int32 `json:"port,omitempty"`
				} `json:"vpc_peering,omitempty"`
			} `json:"connection_strings,omitempty"`

			// NodeMap Node map. The `node_map` is returned only when the `cluster_status` is `"AVAILABLE"` or `"MODIFYING"`.
			NodeMap *struct {
				// Tidb TiDB node map.
				Tidb []struct {
					// AvailabilityZone The availability zone of a node in the cluster.
					AvailabilityZone *string `json:"availability_zone,omitempty"`

					// NodeName The name of a node in the cluster.
					NodeName *string `json:"node_name,omitempty"`

					// NodeSize The size of the TiDB component in the cluster.
					NodeSize *string `json:"node_size,omitempty"`

					// RamBytes The RAM size of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `ram_bytes` is always 0.
					RamBytes *string `json:"ram_bytes,omitempty"`

					// Status The status of a node in the cluster.
					Status *interface{} `json:"status,omitempty"`

					// VcpuNum The total vCPUs of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `vcpu_num` is always 0.
					VcpuNum *int32 `json:"vcpu_num,omitempty"`
				} `json:"tidb"`

				// Tiflash TiFlash node map.
				Tiflash *[]struct {
					// AvailabilityZone The availability zone of a node in the cluster.
					AvailabilityZone *string `json:"availability_zone,omitempty"`

					// NodeName The name of a node in the cluster.
					NodeName *string `json:"node_name,omitempty"`

					// NodeSize The size of the TiFlash component in the cluster.
					NodeSize *string `json:"node_size,omitempty"`

					// RamBytes The RAM size of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `ram_bytes` is always 0.
					RamBytes *string `json:"ram_bytes,omitempty"`

					// Status The status of a node in the cluster.
					Status *interface{} `json:"status,omitempty"`

					// StorageSizeGib The storage size of a node in the cluster.
					StorageSizeGib *int32 `json:"storage_size_gib,omitempty"`

					// VcpuNum The total vCPUs of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `vcpu_num` is always 0.
					VcpuNum *int32 `json:"vcpu_num,omitempty"`
				} `json:"tiflash,omitempty"`

				// Tikv TiKV node map.
				Tikv []struct {
					// AvailabilityZone The availability zone of a node in the cluster.
					AvailabilityZone *string `json:"availability_zone,omitempty"`

					// NodeName The name of a node in the cluster.
					NodeName *string `json:"node_name,omitempty"`

					// NodeSize The size of the TiKV component in the cluster.
					NodeSize *string `json:"node_size,omitempty"`

					// RamBytes The RAM size of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `ram_bytes` is always 0.
					RamBytes *string `json:"ram_bytes,omitempty"`

					// Status The status of a node in the cluster.
					Status *interface{} `json:"status,omitempty"`

					// StorageSizeGib The storage size of a node in the cluster.
					StorageSizeGib *int32 `json:"storage_size_gib,omitempty"`

					// VcpuNum The total vCPUs of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `vcpu_num` is always 0.
					VcpuNum *int32 `json:"vcpu_num,omitempty"`
				} `json:"tikv"`
			} `json:"node_map,omitempty"`

			// TidbVersion TiDB version.
			TidbVersion *string `json:"tidb_version,omitempty"`
		} `json:"status,omitempty"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBackUpOfClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Items The items of all backups.
		Items *[]struct {
			// CreateTimestamp The creation time of the backup in UTC. The time format follows the [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) standard, which is `YYYY-MM-DD` (year-month-day) + T +`HH:MM:SS` (hour-minutes-seconds) + Z. For example, `2020-01-01T00:00:00Z`.
			CreateTimestamp *time.Time `json:"create_timestamp,omitempty"`

			// Description The description of the backup. It is specified by the user when taking a manual type backup. It helps you add additional information to the backup.
			Description *string `json:"description,omitempty"`

			// Id The ID of the backup. It is generated by TiDB Cloud.
			Id *string `json:"id,omitempty"`

			// Name The name of the backup.
			Name *string `json:"name,omitempty"`

			// Size The bytes of the backup.
			Size *string `json:"size,omitempty"`

			// Status The status of backup.
			Status *interface{} `json:"status,omitempty"`

			// Type The type of backup. TiDB Cloud only supports manual and auto backup. For more information, see [TiDB Cloud Documentation](https://docs.pingcap.com/tidbcloud/backup-and-restore#backup).
			Type *interface{} `json:"type,omitempty"`
		} `json:"items,omitempty"`

		// Total The total number of backups in the project.
		Total *int64 `json:"total,omitempty"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBackUpOfClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBackUpOfClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the backup.
		Id *string `json:"id,omitempty"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupOfClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreateTimestamp The creation time of the backup in UTC. The time format follows the [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) standard, which is `YYYY-MM-DD` (year-month-day) + T +`HH:MM:SS` (hour-minutes-seconds) + Z. For example, `2020-01-01T00:00:00Z`.
		CreateTimestamp *time.Time `json:"create_timestamp,omitempty"`

		// Description The description of the backup. It is specified by the user when taking a manual type backup. It helps you add additional information to the backup.
		Description *string `json:"description,omitempty"`

		// Id The ID of the backup.
		Id *string `json:"id,omitempty"`

		// Name The name of the backup.
		Name *string `json:"name,omitempty"`

		// Size The bytes of the backup.
		Size *string `json:"size,omitempty"`

		// Status The status of backup.
		Status *interface{} `json:"status,omitempty"`

		// Type The type of backup. TiDB Cloud only supports manual and auto backup. For more information, see [TiDB Cloud Documentation](https://docs.pingcap.com/tidbcloud/backup-and-restore#backup).
		Type *interface{} `json:"type,omitempty"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBackupOfClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupOfClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListImportTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Items The import tasks in the cluster in the request page area.
		Items []struct {
			// Metadata The metadata of the import task.
			Metadata *struct {
				// CreateTimestamp The creation time of the import task in Unix timestamp seconds (epoch time).
				CreateTimestamp string `json:"create_timestamp"`

				// Id The ID of the import task.
				Id string `json:"id"`

				// Name The name of the import task.
				Name *string `json:"name,omitempty"`
			} `json:"metadata,omitempty"`

			// Spec The specification of the import task.
			Spec *struct {
				// Source The data source settings of the import task.
				Source struct {
					// AwsAssumeRoleAccess The settings to access the S3 data by assuming a specific AWS role. This field is only needed if you need to access S3 data by assuming an AWS role.
					//
					// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
					AwsAssumeRoleAccess *struct {
						// AssumeRole The specific AWS role ARN that needs to be assumed to access the Amazon S3 data source.
						AssumeRole string `json:"assume_role"`
					} `json:"aws_assume_role_access,omitempty"`

					// AwsKeyAccess The settings to access the S3 data with an access key. This field is only needed if you want to access the S3 data with an access key.
					//
					// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
					AwsKeyAccess *struct {
						// AccessKeyId The access key ID of the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
						AccessKeyId string `json:"access_key_id"`

						// SecretAccessKey The secret access key for the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
						SecretAccessKey string `json:"secret_access_key"`
					} `json:"aws_key_access,omitempty"`

					// Format The format settings of the import data source.
					Format struct {
						// CsvConfig The CSV format settings to parse the source CSV files. This field is only needed if the source format is CSV.
						CsvConfig *struct {
							// BackslashEscape Whether a backslash (`\`) symbol followed by a character should be combined as a whole and treated as an escape sequence in a CSV field. For example, if this parameter is set to `true`, `\n` will be treated as a 'new-line' character. If it is set to `false`, `\n` will be treated as two separate characters: backslash and `n`.
							//
							// Currently, these are several supported escape sequences: `\0`, `\b`, `\n`, `\r`, `\t`, and `\Z`. If the parameter is set to `true`, but the backslash escape sequence is not recognized, the backslash character is ignored.
							BackslashEscape *bool `json:"backslash_escape,omitempty"`

							// Delimiter The delimiter character used to separate fields in the CSV data.
							Delimiter *string `json:"delimiter,omitempty"`

							// HasHeaderRow Whether the CSV data has a header row, which is not part of the data. If it is set to `true`, the import task will use the column names in the header row to match the column names in the target table.
							HasHeaderRow *bool `json:"has_header_row,omitempty"`

							// Quote The character used to quote the fields in the CSV data.
							Quote *string `json:"quote,omitempty"`
						} `json:"csv_config,omitempty"`

						// Type The format type of an import source.
						Type interface{} `json:"type"`
					} `json:"format"`

					// Type The data source type of an import task.
					//
					// - `"S3"`: import data from Amazon S3
					// - `"GCS"`: import data from Google Cloud Storage
					// - `"LOCAL_FILE"`: import data from a local file (only available for [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier-beta) clusters). Before you import from a local file, you need to first upload the file using the [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile) endpoint.
					Type interface{} `json:"type"`

					// Uri The data source URI of an import task. The URI scheme must match the data source type. Here are the scheme of each source type:
					// * `S3`: `s3://`
					// * `GCS`: `gs://`
					// * `LOCAL_FILE`: `file://`.
					//
					// **Note:** If the import source type is `LOCAL_FILE`, just provide the `upload_stub_id` of the uploaded file from the response of [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile), and make it as the data source folder. For example: `file://12345/`.
					//
					// **Limitation**: If the import source type is `LOCAL_FILE`, only the `CSV` source format type is supported.
					Uri string `json:"uri"`
				} `json:"source"`

				// Target The target settings of the import task.
				Target struct {
					// Tables The settings for each target table that is being imported for the import task.
					//
					// **Limitations:**
					// * Currently, if you want to use a custom filename pattern, you can only specify one table. If all the tables use the default filename pattern, you can specify more than one target table in `tables`.
					// * It is recommended that you pre-create the target tables before creating an import task. You can do this either by executing the `CREATE TABLE` statement in the cluster or by specifying the table definition in the table creation options.
					// * If a target table is not created, the import module tries to find a **TABLE SCHEMA FILE** containing the `CREATE TABLE` statement of the table in the data source folder with the name `${db_name}.${table_name}-schema.sql` (for example, `db01.tbl01-schema.sql`). If this file is found, the `CREATE TABLE` statement is automatically executed if the table doesn't exist before the actual import process starts. If the table is still missing after this pre-create step, an error will occur.
					Tables *[]struct {
						// DatabaseName The target database name.
						DatabaseName string `json:"database_name"`

						// FileNamePattern The filename pattern used to map the files in the data source to this target table. The pattern should be a simple glob pattern. Here are some examples:
						// * `my-data?.csv`: all CSV files starting with `my-data` and one character (such as `my-data1.csv` and `my-data2.csv`) will be imported into the same target table.
						// * `my-data*.csv`: all CSV files starting with `my-data` will be imported into the same target table.
						//
						// If no pattern is specified, a default pattern is used. The default pattern will try to find files with this naming convention as the data files for this table: `${db_name}.${table_name}.[numeric_index].${format_suffix}`.
						//
						// Here are some examples of filenames that can be matched as data files for the table `db01.table01`: `db01.table01.csv`, `db01.table01.00001.csv`.
						//
						// For more information about the custom file pattern and the default pattern, refer to [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
						//
						// **Note:** For `LOCAL_FILE` import tasks, use the local file name for this field. The local file name must match the local file name in [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile).
						FileNamePattern *string `json:"file_name_pattern,omitempty"`

						// TableName The target table name.
						TableName string `json:"table_name"`
					} `json:"tables,omitempty"`
				} `json:"target"`
			} `json:"spec,omitempty"`

			// Status The status of the import task.
			Status *struct {
				// EndTimestamp The end timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch).
				EndTimestamp *string `json:"end_timestamp,omitempty"`

				// ErrorMessage The error message of the import task.
				ErrorMessage *string `json:"error_message,omitempty"`

				// Phase The current phase that the import task is in.
				Phase interface{} `json:"phase"`

				// Progress The progress of the import task.
				Progress *struct {
					// ImportProgress The overall importing progress of the import task.
					ImportProgress float64 `json:"import_progress"`

					// ValidationProgress The overall validation progress of the import task after the data has been imported into the target cluster.
					ValidationProgress float64 `json:"validation_progress"`
				} `json:"progress,omitempty"`

				// SourceTotalSizeBytes The total size of the import task's data source. The unit is bytes.
				SourceTotalSizeBytes *string `json:"source_total_size_bytes,omitempty"`

				// StartTimestamp The start timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch)
				StartTimestamp *string `json:"start_timestamp,omitempty"`
			} `json:"status,omitempty"`
		} `json:"items"`

		// Total The total number of import tasks in the cluster.
		Total int64 `json:"total"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListImportTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListImportTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImportTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The ID of the import task.
		Id string `json:"id"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateImportTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImportTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewImportDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TablePreviews The preview results for each target table from the import task specification.
		TablePreviews *[]struct {
			// DataPreview The data sample for the preview table.
			DataPreview struct {
				// ColumnNames The column names for the following data samples from a table.
				ColumnNames *[]string `json:"column_names,omitempty"`

				// Rows The rows sampled from a table.
				Rows []struct {
					// Columns The columns extracted from a table row.
					Columns []string `json:"columns"`
				} `json:"rows"`
			} `json:"data_preview"`

			// DatabaseName The database name of the preview table.
			DatabaseName string `json:"database_name"`

			// SchemaPreview The schema for the preview table.
			SchemaPreview *struct {
				// ColumnDefinitions The column definition for each column in the table.
				ColumnDefinitions []struct {
					// ColumnName The column name.
					ColumnName string `json:"column_name"`

					// ColumnType The column type.
					ColumnType string `json:"column_type"`
				} `json:"column_definitions"`

				// PrimaryKeyColumns The primary key column names for the table. This is optional. The primary key is taken into account when the table is pre-created before an import task is started.
				PrimaryKeyColumns *[]string `json:"primary_key_columns,omitempty"`
			} `json:"schema_preview,omitempty"`

			// TableName The table name of the preview table.
			TableName string `json:"table_name"`
		} `json:"table_previews,omitempty"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PreviewImportDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewImportDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImportTaskRoleInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AwsImportRole The import role information for an AWS cluster. Only TiDB clusters on AWS return this information. If the TiDB cluster is deployed on GCP, this field is not returned.
		AwsImportRole *struct {
			// AccountId The account ID under which the import tasks for this cluster are running.
			AccountId string `json:"account_id"`

			// ExternalId The unique external ID that binds to the cluster, which is a long string. When an import task starts and attempts to assume a specified role, it automatically attaches this external ID. This means that you can configure this external ID in the assumed role's trust relationship, so that only the import task of that specified cluster can access the data by assuming the role. This can provide additional security.
			ExternalId string `json:"external_id"`
		} `json:"aws_import_role,omitempty"`

		// GcpImportRole The import role information for a GCP cluster. Only TiDB clusters on GCP return this information. If the TiDB cluster is deployed on AWS, this field is not returned.
		GcpImportRole *struct {
			// AccountId The account ID under which the import tasks for this cluster are running.
			AccountId string `json:"account_id"`
		} `json:"gcp_import_role,omitempty"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetImportTaskRoleInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImportTaskRoleInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadLocalFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// UploadStubId The stub ID for the uploaded file. You can use this stub ID to [create an import task](#tag/Import/operation/CreateImportTask).
		UploadStubId string `json:"upload_stub_id"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UploadLocalFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadLocalFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImportTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Metadata The metadata of the import task.
		Metadata *struct {
			// CreateTimestamp The creation time of the import task in Unix timestamp seconds (epoch time).
			CreateTimestamp string `json:"create_timestamp"`

			// Id The ID of the import task.
			Id string `json:"id"`

			// Name The name of the import task.
			Name *string `json:"name,omitempty"`
		} `json:"metadata,omitempty"`

		// Spec The specification of the import task.
		Spec *struct {
			// Source The data source settings of the import task.
			Source struct {
				// AwsAssumeRoleAccess The settings to access the S3 data by assuming a specific AWS role. This field is only needed if you need to access S3 data by assuming an AWS role.
				//
				// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
				AwsAssumeRoleAccess *struct {
					// AssumeRole The specific AWS role ARN that needs to be assumed to access the Amazon S3 data source.
					AssumeRole string `json:"assume_role"`
				} `json:"aws_assume_role_access,omitempty"`

				// AwsKeyAccess The settings to access the S3 data with an access key. This field is only needed if you want to access the S3 data with an access key.
				//
				// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
				AwsKeyAccess *struct {
					// AccessKeyId The access key ID of the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
					AccessKeyId string `json:"access_key_id"`

					// SecretAccessKey The secret access key for the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
					SecretAccessKey string `json:"secret_access_key"`
				} `json:"aws_key_access,omitempty"`

				// Format The format settings of the import data source.
				Format struct {
					// CsvConfig The CSV format settings to parse the source CSV files. This field is only needed if the source format is CSV.
					CsvConfig *struct {
						// BackslashEscape Whether a backslash (`\`) symbol followed by a character should be combined as a whole and treated as an escape sequence in a CSV field. For example, if this parameter is set to `true`, `\n` will be treated as a 'new-line' character. If it is set to `false`, `\n` will be treated as two separate characters: backslash and `n`.
						//
						// Currently, these are several supported escape sequences: `\0`, `\b`, `\n`, `\r`, `\t`, and `\Z`. If the parameter is set to `true`, but the backslash escape sequence is not recognized, the backslash character is ignored.
						BackslashEscape *bool `json:"backslash_escape,omitempty"`

						// Delimiter The delimiter character used to separate fields in the CSV data.
						Delimiter *string `json:"delimiter,omitempty"`

						// HasHeaderRow Whether the CSV data has a header row, which is not part of the data. If it is set to `true`, the import task will use the column names in the header row to match the column names in the target table.
						HasHeaderRow *bool `json:"has_header_row,omitempty"`

						// Quote The character used to quote the fields in the CSV data.
						Quote *string `json:"quote,omitempty"`
					} `json:"csv_config,omitempty"`

					// Type The format type of an import source.
					Type interface{} `json:"type"`
				} `json:"format"`

				// Type The data source type of an import task.
				//
				// - `"S3"`: import data from Amazon S3
				// - `"GCS"`: import data from Google Cloud Storage
				// - `"LOCAL_FILE"`: import data from a local file (only available for [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier-beta) clusters). Before you import from a local file, you need to first upload the file using the [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile) endpoint.
				Type interface{} `json:"type"`

				// Uri The data source URI of an import task. The URI scheme must match the data source type. Here are the scheme of each source type:
				// * `S3`: `s3://`
				// * `GCS`: `gs://`
				// * `LOCAL_FILE`: `file://`.
				//
				// **Note:** If the import source type is `LOCAL_FILE`, just provide the `upload_stub_id` of the uploaded file from the response of [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile), and make it as the data source folder. For example: `file://12345/`.
				//
				// **Limitation**: If the import source type is `LOCAL_FILE`, only the `CSV` source format type is supported.
				Uri string `json:"uri"`
			} `json:"source"`

			// Target The target settings of the import task.
			Target struct {
				// Tables The settings for each target table that is being imported for the import task.
				//
				// **Limitations:**
				// * Currently, if you want to use a custom filename pattern, you can only specify one table. If all the tables use the default filename pattern, you can specify more than one target table in `tables`.
				// * It is recommended that you pre-create the target tables before creating an import task. You can do this either by executing the `CREATE TABLE` statement in the cluster or by specifying the table definition in the table creation options.
				// * If a target table is not created, the import module tries to find a **TABLE SCHEMA FILE** containing the `CREATE TABLE` statement of the table in the data source folder with the name `${db_name}.${table_name}-schema.sql` (for example, `db01.tbl01-schema.sql`). If this file is found, the `CREATE TABLE` statement is automatically executed if the table doesn't exist before the actual import process starts. If the table is still missing after this pre-create step, an error will occur.
				Tables *[]struct {
					// DatabaseName The target database name.
					DatabaseName string `json:"database_name"`

					// FileNamePattern The filename pattern used to map the files in the data source to this target table. The pattern should be a simple glob pattern. Here are some examples:
					// * `my-data?.csv`: all CSV files starting with `my-data` and one character (such as `my-data1.csv` and `my-data2.csv`) will be imported into the same target table.
					// * `my-data*.csv`: all CSV files starting with `my-data` will be imported into the same target table.
					//
					// If no pattern is specified, a default pattern is used. The default pattern will try to find files with this naming convention as the data files for this table: `${db_name}.${table_name}.[numeric_index].${format_suffix}`.
					//
					// Here are some examples of filenames that can be matched as data files for the table `db01.table01`: `db01.table01.csv`, `db01.table01.00001.csv`.
					//
					// For more information about the custom file pattern and the default pattern, refer to [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
					//
					// **Note:** For `LOCAL_FILE` import tasks, use the local file name for this field. The local file name must match the local file name in [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile).
					FileNamePattern *string `json:"file_name_pattern,omitempty"`

					// TableName The target table name.
					TableName string `json:"table_name"`
				} `json:"tables,omitempty"`
			} `json:"target"`
		} `json:"spec,omitempty"`

		// Status The status of the import task.
		Status *struct {
			// EndTimestamp The end timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch).
			EndTimestamp *string `json:"end_timestamp,omitempty"`

			// ErrorMessage The error message of the import task.
			ErrorMessage *string `json:"error_message,omitempty"`

			// Phase The current phase that the import task is in.
			Phase interface{} `json:"phase"`

			// Progress The progress of the import task.
			Progress *struct {
				// ImportProgress The overall importing progress of the import task.
				ImportProgress float64 `json:"import_progress"`

				// ValidationProgress The overall validation progress of the import task after the data has been imported into the target cluster.
				ValidationProgress float64 `json:"validation_progress"`
			} `json:"progress,omitempty"`

			// SourceTotalSizeBytes The total size of the import task's data source. The unit is bytes.
			SourceTotalSizeBytes *string `json:"source_total_size_bytes,omitempty"`

			// StartTimestamp The start timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch)
			StartTimestamp *string `json:"start_timestamp,omitempty"`
		} `json:"status,omitempty"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetImportTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImportTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateImportTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateImportTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateImportTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRestoreTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Items The items of all restore tasks.
		Items *[]struct {
			// BackupId The ID of the backup.
			BackupId *string `json:"backup_id,omitempty"`

			// Cluster The information of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
			Cluster *struct {
				// Id The ID of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
				Id *string `json:"id,omitempty"`

				// Name The name of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
				Name *string `json:"name,omitempty"`

				// Status The status of the restored cluster. Possible values are `"AVAILABLE"`, `"CREATING"`, `"MODIFYING"`, `"PAUSED"`, `"RESUMING"`, `"UNAVAILABLE"`, `"IMPORTING"`, and `"CLEARED"`.
				Status *interface{} `json:"status,omitempty"`
			} `json:"cluster,omitempty"`

			// ClusterId The cluster ID of the backup.
			ClusterId *string `json:"cluster_id,omitempty"`

			// CreateTimestamp The creation time of the backup in UTC.
			//
			// The time format follows the [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) standard, which is `YYYY-MM-DD` (year-month-day) + T +`HH:MM:SS` (hour-minutes-seconds) + Z. For example, `2020-01-01T00:00:00Z`.
			CreateTimestamp *time.Time `json:"create_timestamp,omitempty"`

			// ErrorMessage The error message of restore if failed.
			ErrorMessage *string `json:"error_message,omitempty"`

			// Id The ID of the restore task.
			Id *string `json:"id,omitempty"`

			// Status The status of the restore task.
			Status *interface{} `json:"status,omitempty"`
		} `json:"items,omitempty"`

		// Total The total number of restore tasks in the project.
		Total *int64 `json:"total,omitempty"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRestoreTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRestoreTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRestoreTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ClusterId The ID of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
		ClusterId *string `json:"cluster_id,omitempty"`

		// Id The ID of the restore task.
		Id *string `json:"id,omitempty"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateRestoreTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRestoreTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRestoreTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BackupId The ID of the backup.
		BackupId *string `json:"backup_id,omitempty"`

		// Cluster The information of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
		Cluster *struct {
			// Id The ID of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
			Id *string `json:"id,omitempty"`

			// Name The name of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
			Name *string `json:"name,omitempty"`

			// Status The status of the restored cluster. Possible values are `"AVAILABLE"`, `"CREATING"`, `"MODIFYING"`, `"PAUSED"`, `"RESUMING"`, `"UNAVAILABLE"`, `"IMPORTING"`, and `"CLEARED"`.
			Status *interface{} `json:"status,omitempty"`
		} `json:"cluster,omitempty"`

		// ClusterId The cluster ID of the backup.
		ClusterId *string `json:"cluster_id,omitempty"`

		// CreateTimestamp The creation time of the backup in UTC.
		//
		// The time format follows the [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) standard, which is `YYYY-MM-DD` (year-month-day) + T +`HH:MM:SS` (hour-minutes-seconds) + Z. For example, `2020-01-01T00:00:00Z`.
		CreateTimestamp *time.Time `json:"create_timestamp,omitempty"`

		// ErrorMessage The error message of restore if failed.
		ErrorMessage *string `json:"error_message,omitempty"`

		// Id The ID of the restore task.
		Id *string `json:"id,omitempty"`

		// Status The status of the restore task.
		Status *interface{} `json:"status,omitempty"`
	}
	JSON400 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON401 *map[string]interface{}
	JSON403 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON429 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {
		// Code Error code returned with this error.
		Code *int `json:"code,omitempty"`

		// Details Error details returned with this error.
		Details *[]string `json:"details,omitempty"`

		// Message Error message returned with this error.
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *struct {
		Code    *int32                               `json:"code,omitempty"`
		Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
		Message *string                              `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRestoreTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRestoreTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListProviderRegionsWithResponse request returning *ListProviderRegionsResponse
func (c *ClientWithResponses) ListProviderRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListProviderRegionsResponse, error) {
	rsp, err := c.ListProviderRegions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProviderRegionsResponse(rsp)
}

// ListProjectsWithResponse request returning *ListProjectsResponse
func (c *ClientWithResponses) ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error) {
	rsp, err := c.ListProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectsResponse(rsp)
}

// CreateProjectWithBodyWithResponse request with arbitrary body returning *CreateProjectResponse
func (c *ClientWithResponses) CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

// ListAwsCmekWithResponse request returning *ListAwsCmekResponse
func (c *ClientWithResponses) ListAwsCmekWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ListAwsCmekResponse, error) {
	rsp, err := c.ListAwsCmek(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAwsCmekResponse(rsp)
}

// CreateAwsCmekWithBodyWithResponse request with arbitrary body returning *CreateAwsCmekResponse
func (c *ClientWithResponses) CreateAwsCmekWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAwsCmekResponse, error) {
	rsp, err := c.CreateAwsCmekWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAwsCmekResponse(rsp)
}

func (c *ClientWithResponses) CreateAwsCmekWithResponse(ctx context.Context, projectId string, body CreateAwsCmekJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAwsCmekResponse, error) {
	rsp, err := c.CreateAwsCmek(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAwsCmekResponse(rsp)
}

// ListClustersOfProjectWithResponse request returning *ListClustersOfProjectResponse
func (c *ClientWithResponses) ListClustersOfProjectWithResponse(ctx context.Context, projectId string, params *ListClustersOfProjectParams, reqEditors ...RequestEditorFn) (*ListClustersOfProjectResponse, error) {
	rsp, err := c.ListClustersOfProject(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClustersOfProjectResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWithResponse(ctx context.Context, projectId string, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateCluster(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, projectId string, clusterId string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, projectId string, clusterId string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterWithResponse(ctx context.Context, projectId string, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateCluster(ctx, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// ListBackUpOfClusterWithResponse request returning *ListBackUpOfClusterResponse
func (c *ClientWithResponses) ListBackUpOfClusterWithResponse(ctx context.Context, projectId string, clusterId string, params *ListBackUpOfClusterParams, reqEditors ...RequestEditorFn) (*ListBackUpOfClusterResponse, error) {
	rsp, err := c.ListBackUpOfCluster(ctx, projectId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBackUpOfClusterResponse(rsp)
}

// CreateBackupWithBodyWithResponse request with arbitrary body returning *CreateBackupResponse
func (c *ClientWithResponses) CreateBackupWithBodyWithResponse(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackupResponse, error) {
	rsp, err := c.CreateBackupWithBody(ctx, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackupResponse(rsp)
}

func (c *ClientWithResponses) CreateBackupWithResponse(ctx context.Context, projectId string, clusterId string, body CreateBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackupResponse, error) {
	rsp, err := c.CreateBackup(ctx, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackupResponse(rsp)
}

// DeleteBackupWithResponse request returning *DeleteBackupResponse
func (c *ClientWithResponses) DeleteBackupWithResponse(ctx context.Context, projectId string, clusterId string, backupId string, reqEditors ...RequestEditorFn) (*DeleteBackupResponse, error) {
	rsp, err := c.DeleteBackup(ctx, projectId, clusterId, backupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackupResponse(rsp)
}

// GetBackupOfClusterWithResponse request returning *GetBackupOfClusterResponse
func (c *ClientWithResponses) GetBackupOfClusterWithResponse(ctx context.Context, projectId string, clusterId string, backupId string, reqEditors ...RequestEditorFn) (*GetBackupOfClusterResponse, error) {
	rsp, err := c.GetBackupOfCluster(ctx, projectId, clusterId, backupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupOfClusterResponse(rsp)
}

// ListImportTasksWithResponse request returning *ListImportTasksResponse
func (c *ClientWithResponses) ListImportTasksWithResponse(ctx context.Context, projectId string, clusterId string, params *ListImportTasksParams, reqEditors ...RequestEditorFn) (*ListImportTasksResponse, error) {
	rsp, err := c.ListImportTasks(ctx, projectId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListImportTasksResponse(rsp)
}

// CreateImportTaskWithBodyWithResponse request with arbitrary body returning *CreateImportTaskResponse
func (c *ClientWithResponses) CreateImportTaskWithBodyWithResponse(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImportTaskResponse, error) {
	rsp, err := c.CreateImportTaskWithBody(ctx, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImportTaskResponse(rsp)
}

func (c *ClientWithResponses) CreateImportTaskWithResponse(ctx context.Context, projectId string, clusterId string, body CreateImportTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImportTaskResponse, error) {
	rsp, err := c.CreateImportTask(ctx, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImportTaskResponse(rsp)
}

// PreviewImportDataWithBodyWithResponse request with arbitrary body returning *PreviewImportDataResponse
func (c *ClientWithResponses) PreviewImportDataWithBodyWithResponse(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewImportDataResponse, error) {
	rsp, err := c.PreviewImportDataWithBody(ctx, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewImportDataResponse(rsp)
}

func (c *ClientWithResponses) PreviewImportDataWithResponse(ctx context.Context, projectId string, clusterId string, body PreviewImportDataJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewImportDataResponse, error) {
	rsp, err := c.PreviewImportData(ctx, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewImportDataResponse(rsp)
}

// GetImportTaskRoleInfoWithResponse request returning *GetImportTaskRoleInfoResponse
func (c *ClientWithResponses) GetImportTaskRoleInfoWithResponse(ctx context.Context, projectId string, clusterId string, reqEditors ...RequestEditorFn) (*GetImportTaskRoleInfoResponse, error) {
	rsp, err := c.GetImportTaskRoleInfo(ctx, projectId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImportTaskRoleInfoResponse(rsp)
}

// UploadLocalFileWithBodyWithResponse request with arbitrary body returning *UploadLocalFileResponse
func (c *ClientWithResponses) UploadLocalFileWithBodyWithResponse(ctx context.Context, projectId string, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLocalFileResponse, error) {
	rsp, err := c.UploadLocalFileWithBody(ctx, projectId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadLocalFileResponse(rsp)
}

func (c *ClientWithResponses) UploadLocalFileWithResponse(ctx context.Context, projectId string, clusterId string, body UploadLocalFileJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadLocalFileResponse, error) {
	rsp, err := c.UploadLocalFile(ctx, projectId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadLocalFileResponse(rsp)
}

// GetImportTaskWithResponse request returning *GetImportTaskResponse
func (c *ClientWithResponses) GetImportTaskWithResponse(ctx context.Context, projectId string, clusterId string, importId string, reqEditors ...RequestEditorFn) (*GetImportTaskResponse, error) {
	rsp, err := c.GetImportTask(ctx, projectId, clusterId, importId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImportTaskResponse(rsp)
}

// UpdateImportTaskWithBodyWithResponse request with arbitrary body returning *UpdateImportTaskResponse
func (c *ClientWithResponses) UpdateImportTaskWithBodyWithResponse(ctx context.Context, projectId string, clusterId string, importId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImportTaskResponse, error) {
	rsp, err := c.UpdateImportTaskWithBody(ctx, projectId, clusterId, importId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImportTaskResponse(rsp)
}

func (c *ClientWithResponses) UpdateImportTaskWithResponse(ctx context.Context, projectId string, clusterId string, importId string, body UpdateImportTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImportTaskResponse, error) {
	rsp, err := c.UpdateImportTask(ctx, projectId, clusterId, importId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImportTaskResponse(rsp)
}

// ListRestoreTasksWithResponse request returning *ListRestoreTasksResponse
func (c *ClientWithResponses) ListRestoreTasksWithResponse(ctx context.Context, projectId string, params *ListRestoreTasksParams, reqEditors ...RequestEditorFn) (*ListRestoreTasksResponse, error) {
	rsp, err := c.ListRestoreTasks(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRestoreTasksResponse(rsp)
}

// CreateRestoreTaskWithBodyWithResponse request with arbitrary body returning *CreateRestoreTaskResponse
func (c *ClientWithResponses) CreateRestoreTaskWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRestoreTaskResponse, error) {
	rsp, err := c.CreateRestoreTaskWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRestoreTaskResponse(rsp)
}

func (c *ClientWithResponses) CreateRestoreTaskWithResponse(ctx context.Context, projectId string, body CreateRestoreTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRestoreTaskResponse, error) {
	rsp, err := c.CreateRestoreTask(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRestoreTaskResponse(rsp)
}

// GetRestoreTaskWithResponse request returning *GetRestoreTaskResponse
func (c *ClientWithResponses) GetRestoreTaskWithResponse(ctx context.Context, projectId string, restoreId string, reqEditors ...RequestEditorFn) (*GetRestoreTaskResponse, error) {
	rsp, err := c.GetRestoreTask(ctx, projectId, restoreId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRestoreTaskResponse(rsp)
}

// ParseListProviderRegionsResponse parses an HTTP response from a ListProviderRegionsWithResponse call
func ParseListProviderRegionsResponse(rsp *http.Response) (*ListProviderRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProviderRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Items Items of provider regions.
			Items *[]struct {
				// CloudProvider The cloud provider on which your TiDB cluster is hosted.
				// - `"AWS"`: the Amazon Web Services cloud provider
				// - `"GCP"`: the Google Cloud Platform cloud provider
				CloudProvider *interface{} `json:"cloud_provider,omitempty"`

				// ClusterType The cluster type.
				// - `"DEVELOPER"`: a [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier) cluster
				// - `"DEDICATED"`: a [Dedicated Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#dedicated-tier) cluster
				//
				// **Warning:** `"DEVELOPER"` will soon be changed to `"SERVERLESS"` to represent Serverless Tier clusters.
				ClusterType *interface{} `json:"cluster_type,omitempty"`

				// Region The region in which your TiDB cluster is hosted.
				//
				// For the detailed information on each region, refer to the documentation of the corresponding cloud provider ([AWS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html) | [GCP](https://cloud.google.com/about/locations#americas)).
				//
				// For example, `"us-west-2"` refers to Oregon for AWS.
				Region *string `json:"region,omitempty"`

				// Tidb The list of TiDB specifications in the region.
				Tidb *[]struct {
					// NodeQuantityRange The range and step of node quantity of the TiDB component in the cluster.
					NodeQuantityRange *struct {
						// Min The minimum node quantity of the component in the cluster.
						Min *int32 `json:"min,omitempty"`

						// Step The step of node quantity of the component in the cluster.
						Step *int32 `json:"step,omitempty"`
					} `json:"node_quantity_range,omitempty"`

					// NodeSize The size of the TiDB component in the cluster.
					NodeSize *string `json:"node_size,omitempty"`
				} `json:"tidb,omitempty"`

				// Tiflash The list of TiFlash specifications in the region.
				Tiflash *[]struct {
					// NodeQuantityRange The range and step of node quantity of the TiFlash component in the cluster.
					NodeQuantityRange *struct {
						// Min The minimum node quantity of the component in the cluster.
						Min *int32 `json:"min,omitempty"`

						// Step The step of node quantity of the component in the cluster.
						Step *int32 `json:"step,omitempty"`
					} `json:"node_quantity_range,omitempty"`

					// NodeSize The size of the TiFlash component in the cluster.
					NodeSize *string `json:"node_size,omitempty"`

					// StorageSizeGibRange The storage size range for each node of the TiFlash component in the cluster.
					StorageSizeGibRange *struct {
						// Max The maximum storage size for each node of the component in the cluster.
						Max *int32 `json:"max,omitempty"`

						// Min The minimum storage size for each node of the component in the cluster.
						Min *int32 `json:"min,omitempty"`
					} `json:"storage_size_gib_range,omitempty"`
				} `json:"tiflash,omitempty"`

				// Tikv The list of TiKV specifications in the region.
				Tikv *[]struct {
					// NodeQuantityRange The range and step of node quantity of the TiKV component in the cluster.
					NodeQuantityRange *struct {
						// Min The minimum node quantity of the component in the cluster.
						Min *int32 `json:"min,omitempty"`

						// Step The step of node quantity of the component in the cluster.
						Step *int32 `json:"step,omitempty"`
					} `json:"node_quantity_range,omitempty"`

					// NodeSize The size of the TiKV component in the cluster.
					NodeSize *string `json:"node_size,omitempty"`

					// StorageSizeGibRange The storage size range for each node of the TiKV component in the cluster.
					StorageSizeGibRange *struct {
						// Max The maximum storage size for each node of the component in the cluster.
						Max *int32 `json:"max,omitempty"`

						// Min The minimum storage size for each node of the component in the cluster.
						Min *int32 `json:"min,omitempty"`
					} `json:"storage_size_gib_range,omitempty"`
				} `json:"tikv,omitempty"`
			} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListProjectsResponse parses an HTTP response from a ListProjectsWithResponse call
func ParseListProjectsResponse(rsp *http.Response) (*ListProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Items The items of accessible projects.
			Items []struct {
				// AwsCmekEnabled Flag that indicates whether to enable AWS Customer-Managed Encryption Keys (CMEK). For more information, see [Encryption at Rest using CMEK](https://docs.pingcap.com/tidbcloud/tidb-cloud-encrypt-cmek).
				//
				// **Note:** Currently, this feature is only available upon request. If you need to try out this feature, contact [support](https://docs.pingcap.com/tidbcloud/tidb-cloud-support).
				AwsCmekEnabled *bool `json:"aws_cmek_enabled,omitempty"`

				// ClusterCount The number of TiDB Cloud clusters deployed in the project.
				ClusterCount *int64 `json:"cluster_count,omitempty"`

				// CreateTimestamp The creation time of the cluster in Unix timestamp seconds (epoch time).
				CreateTimestamp *string `json:"create_timestamp,omitempty"`

				// Id The ID of the project.
				Id *string `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`

				// OrgId The ID of the TiDB Cloud organization to which the project belongs.
				OrgId *string `json:"org_id,omitempty"`

				// UserCount The number of users in the project.
				UserCount *int64 `json:"user_count,omitempty"`
			} `json:"items"`

			// Total The total number of accessible projects.
			Total int64 `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateProjectResponse parses an HTTP response from a CreateProjectWithResponse call
func ParseCreateProjectResponse(rsp *http.Response) (*CreateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the project.
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListAwsCmekResponse parses an HTTP response from a ListAwsCmekWithResponse call
func ParseListAwsCmekResponse(rsp *http.Response) (*ListAwsCmekResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAwsCmekResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Items The specifications of the AWS CMEK.
			Items *[]struct {
				// KmsArn The KMS ARN of the AWS CMEK.
				KmsArn string `json:"kms_arn"`

				// Region The region name of the AWS CMEK. The region value should match the cloud provider's region code.
				//
				// You can get the complete list of available regions from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
				//
				// For the detailed information on each region, refer to the documentation of the [AWS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html) cloud provider.
				Region string `json:"region"`
			} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAwsCmekResponse parses an HTTP response from a CreateAwsCmekWithResponse call
func ParseCreateAwsCmekResponse(rsp *http.Response) (*CreateAwsCmekResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAwsCmekResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListClustersOfProjectResponse parses an HTTP response from a ListClustersOfProjectWithResponse call
func ParseListClustersOfProjectResponse(rsp *http.Response) (*ListClustersOfProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClustersOfProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Items The items of clusters in the project.
			Items []struct {
				// CloudProvider The cloud provider on which your TiDB cluster is hosted.
				// - `"AWS"`: the Amazon Web Services cloud provider
				// - `"GCP"`: the Google Cloud Platform cloud provider
				CloudProvider *interface{} `json:"cloud_provider,omitempty"`

				// ClusterType The cluster type:
				// - `"DEVELOPER"`: a [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier) cluster
				// - `"DEDICATED"`: a [Dedicated Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#dedicated-tier) cluster
				//
				// **Warning:** `"DEVELOPER"` will soon be changed to `"SERVERLESS"` to represent Serverless Tier clusters.
				ClusterType *interface{} `json:"cluster_type,omitempty"`

				// Config The configuration of the cluster.
				Config *struct {
					// Components The components of the cluster.
					Components *struct {
						// Tidb The TiDB component of the cluster.
						Tidb struct {
							// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
							NodeQuantity int32 `json:"node_quantity"`

							// NodeSize The size of the TiDB component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
							//
							// **Additional combination rules**:
							// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
							// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
							NodeSize string `json:"node_size"`
						} `json:"tidb"`

						// Tiflash The TiFlash component of the cluster.
						Tiflash *struct {
							// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
							NodeQuantity int32 `json:"node_quantity"`

							// NodeSize The size of the TiFlash component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
							//
							// **Additional combination rules**:
							// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
							// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
							NodeSize string `json:"node_size"`

							// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
							StorageSizeGib int32 `json:"storage_size_gib"`
						} `json:"tiflash,omitempty"`

						// Tikv The TiKV component of the cluster.
						Tikv struct {
							// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
							//
							// **Limitations**:
							// - The `node_quantity` of TiKV must be a multiple of 3.
							NodeQuantity int32 `json:"node_quantity"`

							// NodeSize The size of the TiKV component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
							//
							// **Additional combination rules**:
							// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
							// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
							NodeSize string `json:"node_size"`

							// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
							StorageSizeGib int32 `json:"storage_size_gib"`
						} `json:"tikv"`
					} `json:"components,omitempty"`

					// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
					Port *int32 `json:"port,omitempty"`
				} `json:"config,omitempty"`

				// CreateTimestamp The creation time of the cluster in Unix timestamp seconds (epoch time).
				CreateTimestamp *string `json:"create_timestamp,omitempty"`

				// Id The ID of the cluster.
				Id string `json:"id"`

				// Name The name of the cluster.
				Name *string `json:"name,omitempty"`

				// ProjectId The ID of the project.
				ProjectId string `json:"project_id"`

				// Region Region of the cluster.
				Region *string `json:"region,omitempty"`

				// Status The status of the cluster.
				Status *struct {
					// ClusterStatus Status of the cluster.
					ClusterStatus *interface{} `json:"cluster_status,omitempty"`

					// ConnectionStrings Connection strings.
					ConnectionStrings *struct {
						// DefaultUser The default TiDB user for connection.
						DefaultUser *string `json:"default_user,omitempty"`

						// Standard Standard connection string.
						//
						// You must configure the [IP Access List](https://docs.pingcap.com/tidbcloud/connect-to-tidb-cluster#connect-via-standard-connection) for the cluster you created on [TiDB Cloud console](https://tidbcloud.com/) before connecting to this connection string.
						Standard *struct {
							// Host The host of standard connection.
							Host *string `json:"host,omitempty"`

							// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
							//
							// **Limitations**:
							// - For a Serverless Tier cluster, only port `4000` is available.
							Port *int32 `json:"port,omitempty"`
						} `json:"standard,omitempty"`

						// VpcPeering [VPC peering](https://docs.pingcap.com/tidbcloud/tidb-cloud-glossary#vpc-peering) connection string.
						//
						// You must [Set up VPC peering connections](https://docs.pingcap.com/tidbcloud/set-up-vpc-peering-connections) for the project before connecting to this private connection string.
						VpcPeering *struct {
							// Host The host of VPC peering connection.
							Host *string `json:"host,omitempty"`

							// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
							//
							// **Limitations**:
							// - For a Serverless Tier cluster, only port `4000` is available.
							Port *int32 `json:"port,omitempty"`
						} `json:"vpc_peering,omitempty"`
					} `json:"connection_strings,omitempty"`

					// NodeMap Node map. The `node_map` is returned only when the `cluster_status` is `"AVAILABLE"` or `"MODIFYING"`.
					NodeMap *struct {
						// Tidb TiDB node map.
						Tidb []struct {
							// AvailabilityZone The availability zone of a node in the cluster.
							AvailabilityZone *string `json:"availability_zone,omitempty"`

							// NodeName The name of a node in the cluster.
							NodeName *string `json:"node_name,omitempty"`

							// NodeSize The size of the TiDB component in the cluster.
							NodeSize *string `json:"node_size,omitempty"`

							// RamBytes The RAM size of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `ram_bytes` is always 0.
							RamBytes *string `json:"ram_bytes,omitempty"`

							// Status The status of a node in the cluster.
							Status *interface{} `json:"status,omitempty"`

							// VcpuNum The total vCPUs of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `vcpu_num` is always 0.
							VcpuNum *int32 `json:"vcpu_num,omitempty"`
						} `json:"tidb"`

						// Tiflash TiFlash node map.
						Tiflash *[]struct {
							// AvailabilityZone The availability zone of a node in the cluster.
							AvailabilityZone *string `json:"availability_zone,omitempty"`

							// NodeName The name of a node in the cluster.
							NodeName *string `json:"node_name,omitempty"`

							// NodeSize The size of the TiFlash component in the cluster.
							NodeSize *string `json:"node_size,omitempty"`

							// RamBytes The RAM size of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `ram_bytes` is always 0.
							RamBytes *string `json:"ram_bytes,omitempty"`

							// Status The status of a node in the cluster.
							Status *interface{} `json:"status,omitempty"`

							// StorageSizeGib The storage size of a node in the cluster.
							StorageSizeGib *int32 `json:"storage_size_gib,omitempty"`

							// VcpuNum The total vCPUs of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `vcpu_num` is always 0.
							VcpuNum *int32 `json:"vcpu_num,omitempty"`
						} `json:"tiflash,omitempty"`

						// Tikv TiKV node map.
						Tikv []struct {
							// AvailabilityZone The availability zone of a node in the cluster.
							AvailabilityZone *string `json:"availability_zone,omitempty"`

							// NodeName The name of a node in the cluster.
							NodeName *string `json:"node_name,omitempty"`

							// NodeSize The size of the TiKV component in the cluster.
							NodeSize *string `json:"node_size,omitempty"`

							// RamBytes The RAM size of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `ram_bytes` is always 0.
							RamBytes *string `json:"ram_bytes,omitempty"`

							// Status The status of a node in the cluster.
							Status *interface{} `json:"status,omitempty"`

							// StorageSizeGib The storage size of a node in the cluster.
							StorageSizeGib *int32 `json:"storage_size_gib,omitempty"`

							// VcpuNum The total vCPUs of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `vcpu_num` is always 0.
							VcpuNum *int32 `json:"vcpu_num,omitempty"`
						} `json:"tikv"`
					} `json:"node_map,omitempty"`

					// TidbVersion TiDB version.
					TidbVersion *string `json:"tidb_version,omitempty"`
				} `json:"status,omitempty"`
			} `json:"items"`

			// Total The total number of clusters in the project.
			Total int64 `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the cluster.
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CloudProvider The cloud provider on which your TiDB cluster is hosted.
			// - `"AWS"`: the Amazon Web Services cloud provider
			// - `"GCP"`: the Google Cloud Platform cloud provider
			CloudProvider *interface{} `json:"cloud_provider,omitempty"`

			// ClusterType The cluster type:
			// - `"DEVELOPER"`: a [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier) cluster
			// - `"DEDICATED"`: a [Dedicated Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#dedicated-tier) cluster
			//
			// **Warning:** `"DEVELOPER"` will soon be changed to `"SERVERLESS"` to represent Serverless Tier clusters.
			ClusterType *interface{} `json:"cluster_type,omitempty"`

			// Config The configuration of the cluster.
			Config *struct {
				// Components The components of the cluster.
				Components *struct {
					// Tidb The TiDB component of the cluster.
					Tidb struct {
						// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						NodeQuantity int32 `json:"node_quantity"`

						// NodeSize The size of the TiDB component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						//
						// **Additional combination rules**:
						// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
						// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
						NodeSize string `json:"node_size"`
					} `json:"tidb"`

					// Tiflash The TiFlash component of the cluster.
					Tiflash *struct {
						// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						NodeQuantity int32 `json:"node_quantity"`

						// NodeSize The size of the TiFlash component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						//
						// **Additional combination rules**:
						// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
						// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
						NodeSize string `json:"node_size"`

						// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						StorageSizeGib int32 `json:"storage_size_gib"`
					} `json:"tiflash,omitempty"`

					// Tikv The TiKV component of the cluster.
					Tikv struct {
						// NodeQuantity The number of nodes in the cluster. You can get the minimum and step of a node quantity from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						//
						// **Limitations**:
						// - The `node_quantity` of TiKV must be a multiple of 3.
						NodeQuantity int32 `json:"node_quantity"`

						// NodeSize The size of the TiKV component in the cluster. You can get the available node size of each region from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						//
						// **Additional combination rules**:
						// - If the vCPUs of TiDB or TiKV component is 2 or 4, then their vCPUs need to be the same.
						// - If the vCPUs of TiDB or TiKV component is 2 or 4, then the cluster does not support TiFlash.
						NodeSize string `json:"node_size"`

						// StorageSizeGib The storage size of a node in the cluster. You can get the minimum and maximum of storage size from the response of [List the cloud providers, regions and available specifications](#tag/Cluster/operation/ListProviderRegions).
						StorageSizeGib int32 `json:"storage_size_gib"`
					} `json:"tikv"`
				} `json:"components,omitempty"`

				// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
				Port *int32 `json:"port,omitempty"`
			} `json:"config,omitempty"`

			// CreateTimestamp The creation time of the cluster in Unix timestamp seconds (epoch time).
			CreateTimestamp *string `json:"create_timestamp,omitempty"`

			// Id The ID of the cluster.
			Id string `json:"id"`

			// Name The name of the cluster.
			Name *string `json:"name,omitempty"`

			// ProjectId The ID of the project.
			ProjectId string `json:"project_id"`

			// Region Region of the cluster.
			Region *string `json:"region,omitempty"`

			// Status The status of the cluster.
			Status *struct {
				// ClusterStatus Status of the cluster.
				ClusterStatus *interface{} `json:"cluster_status,omitempty"`

				// ConnectionStrings Connection strings.
				ConnectionStrings *struct {
					// DefaultUser The default TiDB user for connection.
					DefaultUser *string `json:"default_user,omitempty"`

					// Standard Standard connection string.
					//
					// You must configure the [IP Access List](https://docs.pingcap.com/tidbcloud/connect-to-tidb-cluster#connect-via-standard-connection) for the cluster you created on [TiDB Cloud console](https://tidbcloud.com/) before connecting to this connection string.
					Standard *struct {
						// Host The host of standard connection.
						Host *string `json:"host,omitempty"`

						// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
						//
						// **Limitations**:
						// - For a Serverless Tier cluster, only port `4000` is available.
						Port *int32 `json:"port,omitempty"`
					} `json:"standard,omitempty"`

					// VpcPeering [VPC peering](https://docs.pingcap.com/tidbcloud/tidb-cloud-glossary#vpc-peering) connection string.
					//
					// You must [Set up VPC peering connections](https://docs.pingcap.com/tidbcloud/set-up-vpc-peering-connections) for the project before connecting to this private connection string.
					VpcPeering *struct {
						// Host The host of VPC peering connection.
						Host *string `json:"host,omitempty"`

						// Port The TiDB port for connection. The port must be in the range of 1024-65535 except 10080.
						//
						// **Limitations**:
						// - For a Serverless Tier cluster, only port `4000` is available.
						Port *int32 `json:"port,omitempty"`
					} `json:"vpc_peering,omitempty"`
				} `json:"connection_strings,omitempty"`

				// NodeMap Node map. The `node_map` is returned only when the `cluster_status` is `"AVAILABLE"` or `"MODIFYING"`.
				NodeMap *struct {
					// Tidb TiDB node map.
					Tidb []struct {
						// AvailabilityZone The availability zone of a node in the cluster.
						AvailabilityZone *string `json:"availability_zone,omitempty"`

						// NodeName The name of a node in the cluster.
						NodeName *string `json:"node_name,omitempty"`

						// NodeSize The size of the TiDB component in the cluster.
						NodeSize *string `json:"node_size,omitempty"`

						// RamBytes The RAM size of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `ram_bytes` is always 0.
						RamBytes *string `json:"ram_bytes,omitempty"`

						// Status The status of a node in the cluster.
						Status *interface{} `json:"status,omitempty"`

						// VcpuNum The total vCPUs of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `vcpu_num` is always 0.
						VcpuNum *int32 `json:"vcpu_num,omitempty"`
					} `json:"tidb"`

					// Tiflash TiFlash node map.
					Tiflash *[]struct {
						// AvailabilityZone The availability zone of a node in the cluster.
						AvailabilityZone *string `json:"availability_zone,omitempty"`

						// NodeName The name of a node in the cluster.
						NodeName *string `json:"node_name,omitempty"`

						// NodeSize The size of the TiFlash component in the cluster.
						NodeSize *string `json:"node_size,omitempty"`

						// RamBytes The RAM size of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `ram_bytes` is always 0.
						RamBytes *string `json:"ram_bytes,omitempty"`

						// Status The status of a node in the cluster.
						Status *interface{} `json:"status,omitempty"`

						// StorageSizeGib The storage size of a node in the cluster.
						StorageSizeGib *int32 `json:"storage_size_gib,omitempty"`

						// VcpuNum The total vCPUs of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `vcpu_num` is always 0.
						VcpuNum *int32 `json:"vcpu_num,omitempty"`
					} `json:"tiflash,omitempty"`

					// Tikv TiKV node map.
					Tikv []struct {
						// AvailabilityZone The availability zone of a node in the cluster.
						AvailabilityZone *string `json:"availability_zone,omitempty"`

						// NodeName The name of a node in the cluster.
						NodeName *string `json:"node_name,omitempty"`

						// NodeSize The size of the TiKV component in the cluster.
						NodeSize *string `json:"node_size,omitempty"`

						// RamBytes The RAM size of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `ram_bytes` is always 0.
						RamBytes *string `json:"ram_bytes,omitempty"`

						// Status The status of a node in the cluster.
						Status *interface{} `json:"status,omitempty"`

						// StorageSizeGib The storage size of a node in the cluster.
						StorageSizeGib *int32 `json:"storage_size_gib,omitempty"`

						// VcpuNum The total vCPUs of a node in the cluster. If the `cluster_type` is `"DEVELOPER"`, `vcpu_num` is always 0.
						VcpuNum *int32 `json:"vcpu_num,omitempty"`
					} `json:"tikv"`
				} `json:"node_map,omitempty"`

				// TidbVersion TiDB version.
				TidbVersion *string `json:"tidb_version,omitempty"`
			} `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListBackUpOfClusterResponse parses an HTTP response from a ListBackUpOfClusterWithResponse call
func ParseListBackUpOfClusterResponse(rsp *http.Response) (*ListBackUpOfClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBackUpOfClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Items The items of all backups.
			Items *[]struct {
				// CreateTimestamp The creation time of the backup in UTC. The time format follows the [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) standard, which is `YYYY-MM-DD` (year-month-day) + T +`HH:MM:SS` (hour-minutes-seconds) + Z. For example, `2020-01-01T00:00:00Z`.
				CreateTimestamp *time.Time `json:"create_timestamp,omitempty"`

				// Description The description of the backup. It is specified by the user when taking a manual type backup. It helps you add additional information to the backup.
				Description *string `json:"description,omitempty"`

				// Id The ID of the backup. It is generated by TiDB Cloud.
				Id *string `json:"id,omitempty"`

				// Name The name of the backup.
				Name *string `json:"name,omitempty"`

				// Size The bytes of the backup.
				Size *string `json:"size,omitempty"`

				// Status The status of backup.
				Status *interface{} `json:"status,omitempty"`

				// Type The type of backup. TiDB Cloud only supports manual and auto backup. For more information, see [TiDB Cloud Documentation](https://docs.pingcap.com/tidbcloud/backup-and-restore#backup).
				Type *interface{} `json:"type,omitempty"`
			} `json:"items,omitempty"`

			// Total The total number of backups in the project.
			Total *int64 `json:"total,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBackupResponse parses an HTTP response from a CreateBackupWithResponse call
func ParseCreateBackupResponse(rsp *http.Response) (*CreateBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the backup.
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBackupResponse parses an HTTP response from a DeleteBackupWithResponse call
func ParseDeleteBackupResponse(rsp *http.Response) (*DeleteBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackupOfClusterResponse parses an HTTP response from a GetBackupOfClusterWithResponse call
func ParseGetBackupOfClusterResponse(rsp *http.Response) (*GetBackupOfClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupOfClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreateTimestamp The creation time of the backup in UTC. The time format follows the [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) standard, which is `YYYY-MM-DD` (year-month-day) + T +`HH:MM:SS` (hour-minutes-seconds) + Z. For example, `2020-01-01T00:00:00Z`.
			CreateTimestamp *time.Time `json:"create_timestamp,omitempty"`

			// Description The description of the backup. It is specified by the user when taking a manual type backup. It helps you add additional information to the backup.
			Description *string `json:"description,omitempty"`

			// Id The ID of the backup.
			Id *string `json:"id,omitempty"`

			// Name The name of the backup.
			Name *string `json:"name,omitempty"`

			// Size The bytes of the backup.
			Size *string `json:"size,omitempty"`

			// Status The status of backup.
			Status *interface{} `json:"status,omitempty"`

			// Type The type of backup. TiDB Cloud only supports manual and auto backup. For more information, see [TiDB Cloud Documentation](https://docs.pingcap.com/tidbcloud/backup-and-restore#backup).
			Type *interface{} `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListImportTasksResponse parses an HTTP response from a ListImportTasksWithResponse call
func ParseListImportTasksResponse(rsp *http.Response) (*ListImportTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListImportTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Items The import tasks in the cluster in the request page area.
			Items []struct {
				// Metadata The metadata of the import task.
				Metadata *struct {
					// CreateTimestamp The creation time of the import task in Unix timestamp seconds (epoch time).
					CreateTimestamp string `json:"create_timestamp"`

					// Id The ID of the import task.
					Id string `json:"id"`

					// Name The name of the import task.
					Name *string `json:"name,omitempty"`
				} `json:"metadata,omitempty"`

				// Spec The specification of the import task.
				Spec *struct {
					// Source The data source settings of the import task.
					Source struct {
						// AwsAssumeRoleAccess The settings to access the S3 data by assuming a specific AWS role. This field is only needed if you need to access S3 data by assuming an AWS role.
						//
						// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
						AwsAssumeRoleAccess *struct {
							// AssumeRole The specific AWS role ARN that needs to be assumed to access the Amazon S3 data source.
							AssumeRole string `json:"assume_role"`
						} `json:"aws_assume_role_access,omitempty"`

						// AwsKeyAccess The settings to access the S3 data with an access key. This field is only needed if you want to access the S3 data with an access key.
						//
						// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
						AwsKeyAccess *struct {
							// AccessKeyId The access key ID of the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
							AccessKeyId string `json:"access_key_id"`

							// SecretAccessKey The secret access key for the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
							SecretAccessKey string `json:"secret_access_key"`
						} `json:"aws_key_access,omitempty"`

						// Format The format settings of the import data source.
						Format struct {
							// CsvConfig The CSV format settings to parse the source CSV files. This field is only needed if the source format is CSV.
							CsvConfig *struct {
								// BackslashEscape Whether a backslash (`\`) symbol followed by a character should be combined as a whole and treated as an escape sequence in a CSV field. For example, if this parameter is set to `true`, `\n` will be treated as a 'new-line' character. If it is set to `false`, `\n` will be treated as two separate characters: backslash and `n`.
								//
								// Currently, these are several supported escape sequences: `\0`, `\b`, `\n`, `\r`, `\t`, and `\Z`. If the parameter is set to `true`, but the backslash escape sequence is not recognized, the backslash character is ignored.
								BackslashEscape *bool `json:"backslash_escape,omitempty"`

								// Delimiter The delimiter character used to separate fields in the CSV data.
								Delimiter *string `json:"delimiter,omitempty"`

								// HasHeaderRow Whether the CSV data has a header row, which is not part of the data. If it is set to `true`, the import task will use the column names in the header row to match the column names in the target table.
								HasHeaderRow *bool `json:"has_header_row,omitempty"`

								// Quote The character used to quote the fields in the CSV data.
								Quote *string `json:"quote,omitempty"`
							} `json:"csv_config,omitempty"`

							// Type The format type of an import source.
							Type interface{} `json:"type"`
						} `json:"format"`

						// Type The data source type of an import task.
						//
						// - `"S3"`: import data from Amazon S3
						// - `"GCS"`: import data from Google Cloud Storage
						// - `"LOCAL_FILE"`: import data from a local file (only available for [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier-beta) clusters). Before you import from a local file, you need to first upload the file using the [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile) endpoint.
						Type interface{} `json:"type"`

						// Uri The data source URI of an import task. The URI scheme must match the data source type. Here are the scheme of each source type:
						// * `S3`: `s3://`
						// * `GCS`: `gs://`
						// * `LOCAL_FILE`: `file://`.
						//
						// **Note:** If the import source type is `LOCAL_FILE`, just provide the `upload_stub_id` of the uploaded file from the response of [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile), and make it as the data source folder. For example: `file://12345/`.
						//
						// **Limitation**: If the import source type is `LOCAL_FILE`, only the `CSV` source format type is supported.
						Uri string `json:"uri"`
					} `json:"source"`

					// Target The target settings of the import task.
					Target struct {
						// Tables The settings for each target table that is being imported for the import task.
						//
						// **Limitations:**
						// * Currently, if you want to use a custom filename pattern, you can only specify one table. If all the tables use the default filename pattern, you can specify more than one target table in `tables`.
						// * It is recommended that you pre-create the target tables before creating an import task. You can do this either by executing the `CREATE TABLE` statement in the cluster or by specifying the table definition in the table creation options.
						// * If a target table is not created, the import module tries to find a **TABLE SCHEMA FILE** containing the `CREATE TABLE` statement of the table in the data source folder with the name `${db_name}.${table_name}-schema.sql` (for example, `db01.tbl01-schema.sql`). If this file is found, the `CREATE TABLE` statement is automatically executed if the table doesn't exist before the actual import process starts. If the table is still missing after this pre-create step, an error will occur.
						Tables *[]struct {
							// DatabaseName The target database name.
							DatabaseName string `json:"database_name"`

							// FileNamePattern The filename pattern used to map the files in the data source to this target table. The pattern should be a simple glob pattern. Here are some examples:
							// * `my-data?.csv`: all CSV files starting with `my-data` and one character (such as `my-data1.csv` and `my-data2.csv`) will be imported into the same target table.
							// * `my-data*.csv`: all CSV files starting with `my-data` will be imported into the same target table.
							//
							// If no pattern is specified, a default pattern is used. The default pattern will try to find files with this naming convention as the data files for this table: `${db_name}.${table_name}.[numeric_index].${format_suffix}`.
							//
							// Here are some examples of filenames that can be matched as data files for the table `db01.table01`: `db01.table01.csv`, `db01.table01.00001.csv`.
							//
							// For more information about the custom file pattern and the default pattern, refer to [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
							//
							// **Note:** For `LOCAL_FILE` import tasks, use the local file name for this field. The local file name must match the local file name in [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile).
							FileNamePattern *string `json:"file_name_pattern,omitempty"`

							// TableName The target table name.
							TableName string `json:"table_name"`
						} `json:"tables,omitempty"`
					} `json:"target"`
				} `json:"spec,omitempty"`

				// Status The status of the import task.
				Status *struct {
					// EndTimestamp The end timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch).
					EndTimestamp *string `json:"end_timestamp,omitempty"`

					// ErrorMessage The error message of the import task.
					ErrorMessage *string `json:"error_message,omitempty"`

					// Phase The current phase that the import task is in.
					Phase interface{} `json:"phase"`

					// Progress The progress of the import task.
					Progress *struct {
						// ImportProgress The overall importing progress of the import task.
						ImportProgress float64 `json:"import_progress"`

						// ValidationProgress The overall validation progress of the import task after the data has been imported into the target cluster.
						ValidationProgress float64 `json:"validation_progress"`
					} `json:"progress,omitempty"`

					// SourceTotalSizeBytes The total size of the import task's data source. The unit is bytes.
					SourceTotalSizeBytes *string `json:"source_total_size_bytes,omitempty"`

					// StartTimestamp The start timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch)
					StartTimestamp *string `json:"start_timestamp,omitempty"`
				} `json:"status,omitempty"`
			} `json:"items"`

			// Total The total number of import tasks in the cluster.
			Total int64 `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateImportTaskResponse parses an HTTP response from a CreateImportTaskWithResponse call
func ParseCreateImportTaskResponse(rsp *http.Response) (*CreateImportTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImportTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The ID of the import task.
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePreviewImportDataResponse parses an HTTP response from a PreviewImportDataWithResponse call
func ParsePreviewImportDataResponse(rsp *http.Response) (*PreviewImportDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewImportDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TablePreviews The preview results for each target table from the import task specification.
			TablePreviews *[]struct {
				// DataPreview The data sample for the preview table.
				DataPreview struct {
					// ColumnNames The column names for the following data samples from a table.
					ColumnNames *[]string `json:"column_names,omitempty"`

					// Rows The rows sampled from a table.
					Rows []struct {
						// Columns The columns extracted from a table row.
						Columns []string `json:"columns"`
					} `json:"rows"`
				} `json:"data_preview"`

				// DatabaseName The database name of the preview table.
				DatabaseName string `json:"database_name"`

				// SchemaPreview The schema for the preview table.
				SchemaPreview *struct {
					// ColumnDefinitions The column definition for each column in the table.
					ColumnDefinitions []struct {
						// ColumnName The column name.
						ColumnName string `json:"column_name"`

						// ColumnType The column type.
						ColumnType string `json:"column_type"`
					} `json:"column_definitions"`

					// PrimaryKeyColumns The primary key column names for the table. This is optional. The primary key is taken into account when the table is pre-created before an import task is started.
					PrimaryKeyColumns *[]string `json:"primary_key_columns,omitempty"`
				} `json:"schema_preview,omitempty"`

				// TableName The table name of the preview table.
				TableName string `json:"table_name"`
			} `json:"table_previews,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetImportTaskRoleInfoResponse parses an HTTP response from a GetImportTaskRoleInfoWithResponse call
func ParseGetImportTaskRoleInfoResponse(rsp *http.Response) (*GetImportTaskRoleInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImportTaskRoleInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AwsImportRole The import role information for an AWS cluster. Only TiDB clusters on AWS return this information. If the TiDB cluster is deployed on GCP, this field is not returned.
			AwsImportRole *struct {
				// AccountId The account ID under which the import tasks for this cluster are running.
				AccountId string `json:"account_id"`

				// ExternalId The unique external ID that binds to the cluster, which is a long string. When an import task starts and attempts to assume a specified role, it automatically attaches this external ID. This means that you can configure this external ID in the assumed role's trust relationship, so that only the import task of that specified cluster can access the data by assuming the role. This can provide additional security.
				ExternalId string `json:"external_id"`
			} `json:"aws_import_role,omitempty"`

			// GcpImportRole The import role information for a GCP cluster. Only TiDB clusters on GCP return this information. If the TiDB cluster is deployed on AWS, this field is not returned.
			GcpImportRole *struct {
				// AccountId The account ID under which the import tasks for this cluster are running.
				AccountId string `json:"account_id"`
			} `json:"gcp_import_role,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadLocalFileResponse parses an HTTP response from a UploadLocalFileWithResponse call
func ParseUploadLocalFileResponse(rsp *http.Response) (*UploadLocalFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadLocalFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// UploadStubId The stub ID for the uploaded file. You can use this stub ID to [create an import task](#tag/Import/operation/CreateImportTask).
			UploadStubId string `json:"upload_stub_id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetImportTaskResponse parses an HTTP response from a GetImportTaskWithResponse call
func ParseGetImportTaskResponse(rsp *http.Response) (*GetImportTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImportTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Metadata The metadata of the import task.
			Metadata *struct {
				// CreateTimestamp The creation time of the import task in Unix timestamp seconds (epoch time).
				CreateTimestamp string `json:"create_timestamp"`

				// Id The ID of the import task.
				Id string `json:"id"`

				// Name The name of the import task.
				Name *string `json:"name,omitempty"`
			} `json:"metadata,omitempty"`

			// Spec The specification of the import task.
			Spec *struct {
				// Source The data source settings of the import task.
				Source struct {
					// AwsAssumeRoleAccess The settings to access the S3 data by assuming a specific AWS role. This field is only needed if you need to access S3 data by assuming an AWS role.
					//
					// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
					AwsAssumeRoleAccess *struct {
						// AssumeRole The specific AWS role ARN that needs to be assumed to access the Amazon S3 data source.
						AssumeRole string `json:"assume_role"`
					} `json:"aws_assume_role_access,omitempty"`

					// AwsKeyAccess The settings to access the S3 data with an access key. This field is only needed if you want to access the S3 data with an access key.
					//
					// **Note:** Provide only one of `aws_assume_role_access` and `aws_key_access`. If both `aws_assume_role_access` and `aws_key_access` are provided, an error will be reported.
					AwsKeyAccess *struct {
						// AccessKeyId The access key ID of the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
						AccessKeyId string `json:"access_key_id"`

						// SecretAccessKey The secret access key for the account to access the data. This information will be redacted when it is retrieved to obtain the import task information.
						SecretAccessKey string `json:"secret_access_key"`
					} `json:"aws_key_access,omitempty"`

					// Format The format settings of the import data source.
					Format struct {
						// CsvConfig The CSV format settings to parse the source CSV files. This field is only needed if the source format is CSV.
						CsvConfig *struct {
							// BackslashEscape Whether a backslash (`\`) symbol followed by a character should be combined as a whole and treated as an escape sequence in a CSV field. For example, if this parameter is set to `true`, `\n` will be treated as a 'new-line' character. If it is set to `false`, `\n` will be treated as two separate characters: backslash and `n`.
							//
							// Currently, these are several supported escape sequences: `\0`, `\b`, `\n`, `\r`, `\t`, and `\Z`. If the parameter is set to `true`, but the backslash escape sequence is not recognized, the backslash character is ignored.
							BackslashEscape *bool `json:"backslash_escape,omitempty"`

							// Delimiter The delimiter character used to separate fields in the CSV data.
							Delimiter *string `json:"delimiter,omitempty"`

							// HasHeaderRow Whether the CSV data has a header row, which is not part of the data. If it is set to `true`, the import task will use the column names in the header row to match the column names in the target table.
							HasHeaderRow *bool `json:"has_header_row,omitempty"`

							// Quote The character used to quote the fields in the CSV data.
							Quote *string `json:"quote,omitempty"`
						} `json:"csv_config,omitempty"`

						// Type The format type of an import source.
						Type interface{} `json:"type"`
					} `json:"format"`

					// Type The data source type of an import task.
					//
					// - `"S3"`: import data from Amazon S3
					// - `"GCS"`: import data from Google Cloud Storage
					// - `"LOCAL_FILE"`: import data from a local file (only available for [Serverless Tier](https://docs.pingcap.com/tidbcloud/select-cluster-tier#serverless-tier-beta) clusters). Before you import from a local file, you need to first upload the file using the [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile) endpoint.
					Type interface{} `json:"type"`

					// Uri The data source URI of an import task. The URI scheme must match the data source type. Here are the scheme of each source type:
					// * `S3`: `s3://`
					// * `GCS`: `gs://`
					// * `LOCAL_FILE`: `file://`.
					//
					// **Note:** If the import source type is `LOCAL_FILE`, just provide the `upload_stub_id` of the uploaded file from the response of [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile), and make it as the data source folder. For example: `file://12345/`.
					//
					// **Limitation**: If the import source type is `LOCAL_FILE`, only the `CSV` source format type is supported.
					Uri string `json:"uri"`
				} `json:"source"`

				// Target The target settings of the import task.
				Target struct {
					// Tables The settings for each target table that is being imported for the import task.
					//
					// **Limitations:**
					// * Currently, if you want to use a custom filename pattern, you can only specify one table. If all the tables use the default filename pattern, you can specify more than one target table in `tables`.
					// * It is recommended that you pre-create the target tables before creating an import task. You can do this either by executing the `CREATE TABLE` statement in the cluster or by specifying the table definition in the table creation options.
					// * If a target table is not created, the import module tries to find a **TABLE SCHEMA FILE** containing the `CREATE TABLE` statement of the table in the data source folder with the name `${db_name}.${table_name}-schema.sql` (for example, `db01.tbl01-schema.sql`). If this file is found, the `CREATE TABLE` statement is automatically executed if the table doesn't exist before the actual import process starts. If the table is still missing after this pre-create step, an error will occur.
					Tables *[]struct {
						// DatabaseName The target database name.
						DatabaseName string `json:"database_name"`

						// FileNamePattern The filename pattern used to map the files in the data source to this target table. The pattern should be a simple glob pattern. Here are some examples:
						// * `my-data?.csv`: all CSV files starting with `my-data` and one character (such as `my-data1.csv` and `my-data2.csv`) will be imported into the same target table.
						// * `my-data*.csv`: all CSV files starting with `my-data` will be imported into the same target table.
						//
						// If no pattern is specified, a default pattern is used. The default pattern will try to find files with this naming convention as the data files for this table: `${db_name}.${table_name}.[numeric_index].${format_suffix}`.
						//
						// Here are some examples of filenames that can be matched as data files for the table `db01.table01`: `db01.table01.csv`, `db01.table01.00001.csv`.
						//
						// For more information about the custom file pattern and the default pattern, refer to [Import CSV Files from Amazon S3 or GCS into TiDB Cloud](https://docs.pingcap.com/tidbcloud/import-csv-files).
						//
						// **Note:** For `LOCAL_FILE` import tasks, use the local file name for this field. The local file name must match the local file name in [Upload a local file for an import task](#tag/Import/operation/UploadLocalFile).
						FileNamePattern *string `json:"file_name_pattern,omitempty"`

						// TableName The target table name.
						TableName string `json:"table_name"`
					} `json:"tables,omitempty"`
				} `json:"target"`
			} `json:"spec,omitempty"`

			// Status The status of the import task.
			Status *struct {
				// EndTimestamp The end timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch).
				EndTimestamp *string `json:"end_timestamp,omitempty"`

				// ErrorMessage The error message of the import task.
				ErrorMessage *string `json:"error_message,omitempty"`

				// Phase The current phase that the import task is in.
				Phase interface{} `json:"phase"`

				// Progress The progress of the import task.
				Progress *struct {
					// ImportProgress The overall importing progress of the import task.
					ImportProgress float64 `json:"import_progress"`

					// ValidationProgress The overall validation progress of the import task after the data has been imported into the target cluster.
					ValidationProgress float64 `json:"validation_progress"`
				} `json:"progress,omitempty"`

				// SourceTotalSizeBytes The total size of the import task's data source. The unit is bytes.
				SourceTotalSizeBytes *string `json:"source_total_size_bytes,omitempty"`

				// StartTimestamp The start timestamp of the import task. The format is Unix timestamp (the seconds elapsed since the Unix epoch)
				StartTimestamp *string `json:"start_timestamp,omitempty"`
			} `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateImportTaskResponse parses an HTTP response from a UpdateImportTaskWithResponse call
func ParseUpdateImportTaskResponse(rsp *http.Response) (*UpdateImportTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateImportTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRestoreTasksResponse parses an HTTP response from a ListRestoreTasksWithResponse call
func ParseListRestoreTasksResponse(rsp *http.Response) (*ListRestoreTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRestoreTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Items The items of all restore tasks.
			Items *[]struct {
				// BackupId The ID of the backup.
				BackupId *string `json:"backup_id,omitempty"`

				// Cluster The information of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
				Cluster *struct {
					// Id The ID of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
					Id *string `json:"id,omitempty"`

					// Name The name of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
					Name *string `json:"name,omitempty"`

					// Status The status of the restored cluster. Possible values are `"AVAILABLE"`, `"CREATING"`, `"MODIFYING"`, `"PAUSED"`, `"RESUMING"`, `"UNAVAILABLE"`, `"IMPORTING"`, and `"CLEARED"`.
					Status *interface{} `json:"status,omitempty"`
				} `json:"cluster,omitempty"`

				// ClusterId The cluster ID of the backup.
				ClusterId *string `json:"cluster_id,omitempty"`

				// CreateTimestamp The creation time of the backup in UTC.
				//
				// The time format follows the [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) standard, which is `YYYY-MM-DD` (year-month-day) + T +`HH:MM:SS` (hour-minutes-seconds) + Z. For example, `2020-01-01T00:00:00Z`.
				CreateTimestamp *time.Time `json:"create_timestamp,omitempty"`

				// ErrorMessage The error message of restore if failed.
				ErrorMessage *string `json:"error_message,omitempty"`

				// Id The ID of the restore task.
				Id *string `json:"id,omitempty"`

				// Status The status of the restore task.
				Status *interface{} `json:"status,omitempty"`
			} `json:"items,omitempty"`

			// Total The total number of restore tasks in the project.
			Total *int64 `json:"total,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRestoreTaskResponse parses an HTTP response from a CreateRestoreTaskWithResponse call
func ParseCreateRestoreTaskResponse(rsp *http.Response) (*CreateRestoreTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRestoreTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ClusterId The ID of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
			ClusterId *string `json:"cluster_id,omitempty"`

			// Id The ID of the restore task.
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRestoreTaskResponse parses an HTTP response from a GetRestoreTaskWithResponse call
func ParseGetRestoreTaskResponse(rsp *http.Response) (*GetRestoreTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRestoreTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BackupId The ID of the backup.
			BackupId *string `json:"backup_id,omitempty"`

			// Cluster The information of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
			Cluster *struct {
				// Id The ID of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
				Id *string `json:"id,omitempty"`

				// Name The name of the restored cluster. The restored cluster is the new cluster your backup data is restored to.
				Name *string `json:"name,omitempty"`

				// Status The status of the restored cluster. Possible values are `"AVAILABLE"`, `"CREATING"`, `"MODIFYING"`, `"PAUSED"`, `"RESUMING"`, `"UNAVAILABLE"`, `"IMPORTING"`, and `"CLEARED"`.
				Status *interface{} `json:"status,omitempty"`
			} `json:"cluster,omitempty"`

			// ClusterId The cluster ID of the backup.
			ClusterId *string `json:"cluster_id,omitempty"`

			// CreateTimestamp The creation time of the backup in UTC.
			//
			// The time format follows the [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) standard, which is `YYYY-MM-DD` (year-month-day) + T +`HH:MM:SS` (hour-minutes-seconds) + Z. For example, `2020-01-01T00:00:00Z`.
			CreateTimestamp *time.Time `json:"create_timestamp,omitempty"`

			// ErrorMessage The error message of restore if failed.
			ErrorMessage *string `json:"error_message,omitempty"`

			// Id The ID of the restore task.
			Id *string `json:"id,omitempty"`

			// Status The status of the restore task.
			Status *interface{} `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Code Error code returned with this error.
			Code *int `json:"code,omitempty"`

			// Details Error details returned with this error.
			Details *[]string `json:"details,omitempty"`

			// Message Error message returned with this error.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    *int32                               `json:"code,omitempty"`
			Details *[]map[string]map[string]interface{} `json:"details,omitempty"`
			Message *string                              `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List the cloud providers, regions and available specifications.
	// (GET /api/v1beta/clusters/provider/regions)
	ListProviderRegions(ctx echo.Context) error
	// List all accessible projects.
	// (GET /api/v1beta/projects)
	ListProjects(ctx echo.Context, params ListProjectsParams) error
	// Create a project.
	// (POST /api/v1beta/projects)
	CreateProject(ctx echo.Context) error
	// List AWS Customer-Managed Encryption Keys for a project.
	// (GET /api/v1beta/projects/{project_id}/aws-cmek)
	ListAwsCmek(ctx echo.Context, projectId string) error
	// Configure AWS Customer-Managed Encryption Keys for a project.
	// (POST /api/v1beta/projects/{project_id}/aws-cmek)
	CreateAwsCmek(ctx echo.Context, projectId string) error
	// List all clusters in a project.
	// (GET /api/v1beta/projects/{project_id}/clusters)
	ListClustersOfProject(ctx echo.Context, projectId string, params ListClustersOfProjectParams) error
	// Create a cluster.
	// (POST /api/v1beta/projects/{project_id}/clusters)
	CreateCluster(ctx echo.Context, projectId string) error
	// Delete a cluster.
	// (DELETE /api/v1beta/projects/{project_id}/clusters/{cluster_id})
	DeleteCluster(ctx echo.Context, projectId string, clusterId string) error
	// Get a cluster by ID.
	// (GET /api/v1beta/projects/{project_id}/clusters/{cluster_id})
	GetCluster(ctx echo.Context, projectId string, clusterId string) error
	// Modify a Dedicated Tier cluster.
	// (PATCH /api/v1beta/projects/{project_id}/clusters/{cluster_id})
	UpdateCluster(ctx echo.Context, projectId string, clusterId string) error
	// List all backups for a cluster.
	// (GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/backups)
	ListBackUpOfCluster(ctx echo.Context, projectId string, clusterId string, params ListBackUpOfClusterParams) error
	// Create a backup for a cluster.
	// (POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/backups)
	CreateBackup(ctx echo.Context, projectId string, clusterId string) error
	// Delete a backup for a cluster.
	// (DELETE /api/v1beta/projects/{project_id}/clusters/{cluster_id}/backups/{backup_id})
	DeleteBackup(ctx echo.Context, projectId string, clusterId string, backupId string) error
	// Get a backup for a cluster.
	// (GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/backups/{backup_id})
	GetBackupOfCluster(ctx echo.Context, projectId string, clusterId string, backupId string) error
	// List all import tasks for a cluster.
	// (GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports)
	ListImportTasks(ctx echo.Context, projectId string, clusterId string, params ListImportTasksParams) error
	// Create an import task.
	// (POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports)
	CreateImportTask(ctx echo.Context, projectId string, clusterId string) error
	// Preview data before starting an import task.
	// (POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/preview)
	PreviewImportData(ctx echo.Context, projectId string, clusterId string) error
	// Retrieve the role information for import tasks on a cluster.
	// (GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/role_info)
	GetImportTaskRoleInfo(ctx echo.Context, projectId string, clusterId string) error
	// Upload a local file for an import task.
	// (POST /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/upload_file)
	UploadLocalFile(ctx echo.Context, projectId string, clusterId string) error
	// Get an import task.
	// (GET /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id})
	GetImportTask(ctx echo.Context, projectId string, clusterId string, importId string) error
	// Update an import task.
	// (PATCH /api/v1beta/projects/{project_id}/clusters/{cluster_id}/imports/{import_id})
	UpdateImportTask(ctx echo.Context, projectId string, clusterId string, importId string) error
	// List the restore tasks in a project.
	// (GET /api/v1beta/projects/{project_id}/restores)
	ListRestoreTasks(ctx echo.Context, projectId string, params ListRestoreTasksParams) error
	// Create a restore task.
	// (POST /api/v1beta/projects/{project_id}/restores)
	CreateRestoreTask(ctx echo.Context, projectId string) error
	// Get a restore task.
	// (GET /api/v1beta/projects/{project_id}/restores/{restore_id})
	GetRestoreTask(ctx echo.Context, projectId string, restoreId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListProviderRegions converts echo context to params.
func (w *ServerInterfaceWrapper) ListProviderRegions(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListProviderRegions(ctx)
	return err
}

// ListProjects converts echo context to params.
func (w *ServerInterfaceWrapper) ListProjects(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_size: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListProjects(ctx, params)
	return err
}

// CreateProject converts echo context to params.
func (w *ServerInterfaceWrapper) CreateProject(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateProject(ctx)
	return err
}

// ListAwsCmek converts echo context to params.
func (w *ServerInterfaceWrapper) ListAwsCmek(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAwsCmek(ctx, projectId)
	return err
}

// CreateAwsCmek converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAwsCmek(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateAwsCmek(ctx, projectId)
	return err
}

// ListClustersOfProject converts echo context to params.
func (w *ServerInterfaceWrapper) ListClustersOfProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListClustersOfProjectParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_size: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListClustersOfProject(ctx, projectId, params)
	return err
}

// CreateCluster converts echo context to params.
func (w *ServerInterfaceWrapper) CreateCluster(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateCluster(ctx, projectId)
	return err
}

// DeleteCluster converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCluster(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteCluster(ctx, projectId, clusterId)
	return err
}

// GetCluster converts echo context to params.
func (w *ServerInterfaceWrapper) GetCluster(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCluster(ctx, projectId, clusterId)
	return err
}

// UpdateCluster converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCluster(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateCluster(ctx, projectId, clusterId)
	return err
}

// ListBackUpOfCluster converts echo context to params.
func (w *ServerInterfaceWrapper) ListBackUpOfCluster(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBackUpOfClusterParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_size: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListBackUpOfCluster(ctx, projectId, clusterId, params)
	return err
}

// CreateBackup converts echo context to params.
func (w *ServerInterfaceWrapper) CreateBackup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateBackup(ctx, projectId, clusterId)
	return err
}

// DeleteBackup converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteBackup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// ------------- Path parameter "backup_id" -------------
	var backupId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "backup_id", runtime.ParamLocationPath, ctx.Param("backup_id"), &backupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter backup_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteBackup(ctx, projectId, clusterId, backupId)
	return err
}

// GetBackupOfCluster converts echo context to params.
func (w *ServerInterfaceWrapper) GetBackupOfCluster(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// ------------- Path parameter "backup_id" -------------
	var backupId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "backup_id", runtime.ParamLocationPath, ctx.Param("backup_id"), &backupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter backup_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBackupOfCluster(ctx, projectId, clusterId, backupId)
	return err
}

// ListImportTasks converts echo context to params.
func (w *ServerInterfaceWrapper) ListImportTasks(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListImportTasksParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_size: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListImportTasks(ctx, projectId, clusterId, params)
	return err
}

// CreateImportTask converts echo context to params.
func (w *ServerInterfaceWrapper) CreateImportTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateImportTask(ctx, projectId, clusterId)
	return err
}

// PreviewImportData converts echo context to params.
func (w *ServerInterfaceWrapper) PreviewImportData(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PreviewImportData(ctx, projectId, clusterId)
	return err
}

// GetImportTaskRoleInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetImportTaskRoleInfo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetImportTaskRoleInfo(ctx, projectId, clusterId)
	return err
}

// UploadLocalFile converts echo context to params.
func (w *ServerInterfaceWrapper) UploadLocalFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UploadLocalFile(ctx, projectId, clusterId)
	return err
}

// GetImportTask converts echo context to params.
func (w *ServerInterfaceWrapper) GetImportTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// ------------- Path parameter "import_id" -------------
	var importId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "import_id", runtime.ParamLocationPath, ctx.Param("import_id"), &importId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter import_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetImportTask(ctx, projectId, clusterId, importId)
	return err
}

// UpdateImportTask converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateImportTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "cluster_id" -------------
	var clusterId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, ctx.Param("cluster_id"), &clusterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cluster_id: %s", err))
	}

	// ------------- Path parameter "import_id" -------------
	var importId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "import_id", runtime.ParamLocationPath, ctx.Param("import_id"), &importId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter import_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateImportTask(ctx, projectId, clusterId, importId)
	return err
}

// ListRestoreTasks converts echo context to params.
func (w *ServerInterfaceWrapper) ListRestoreTasks(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRestoreTasksParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_size: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRestoreTasks(ctx, projectId, params)
	return err
}

// CreateRestoreTask converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRestoreTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRestoreTask(ctx, projectId)
	return err
}

// GetRestoreTask converts echo context to params.
func (w *ServerInterfaceWrapper) GetRestoreTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "restore_id" -------------
	var restoreId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "restore_id", runtime.ParamLocationPath, ctx.Param("restore_id"), &restoreId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter restore_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRestoreTask(ctx, projectId, restoreId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1beta/clusters/provider/regions", wrapper.ListProviderRegions)
	router.GET(baseURL+"/api/v1beta/projects", wrapper.ListProjects)
	router.POST(baseURL+"/api/v1beta/projects", wrapper.CreateProject)
	router.GET(baseURL+"/api/v1beta/projects/:project_id/aws-cmek", wrapper.ListAwsCmek)
	router.POST(baseURL+"/api/v1beta/projects/:project_id/aws-cmek", wrapper.CreateAwsCmek)
	router.GET(baseURL+"/api/v1beta/projects/:project_id/clusters", wrapper.ListClustersOfProject)
	router.POST(baseURL+"/api/v1beta/projects/:project_id/clusters", wrapper.CreateCluster)
	router.DELETE(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id", wrapper.DeleteCluster)
	router.GET(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id", wrapper.GetCluster)
	router.PATCH(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id", wrapper.UpdateCluster)
	router.GET(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id/backups", wrapper.ListBackUpOfCluster)
	router.POST(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id/backups", wrapper.CreateBackup)
	router.DELETE(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id/backups/:backup_id", wrapper.DeleteBackup)
	router.GET(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id/backups/:backup_id", wrapper.GetBackupOfCluster)
	router.GET(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id/imports", wrapper.ListImportTasks)
	router.POST(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id/imports", wrapper.CreateImportTask)
	router.POST(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id/imports/preview", wrapper.PreviewImportData)
	router.GET(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id/imports/role_info", wrapper.GetImportTaskRoleInfo)
	router.POST(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id/imports/upload_file", wrapper.UploadLocalFile)
	router.GET(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id/imports/:import_id", wrapper.GetImportTask)
	router.PATCH(baseURL+"/api/v1beta/projects/:project_id/clusters/:cluster_id/imports/:import_id", wrapper.UpdateImportTask)
	router.GET(baseURL+"/api/v1beta/projects/:project_id/restores", wrapper.ListRestoreTasks)
	router.POST(baseURL+"/api/v1beta/projects/:project_id/restores", wrapper.CreateRestoreTask)
	router.GET(baseURL+"/api/v1beta/projects/:project_id/restores/:restore_id", wrapper.GetRestoreTask)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
